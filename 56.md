1. Qt的信号与槽机制是**线程安全的**

- [ ] 11_19



2. 

如何理解moveToThread()
Qt官方实现多线程 是如何实现的？



3. QThread::start()

- 请求操作系统创建一个新的执行线程
- 并在这个新线程调用 run方法
- 非阻塞的函数
- 让线程进入 “接受和处理事件/信号”的待命状态



4. 

connect(...) 是设置阶段：它在主线程执行，作用是建立一个连接。它告诉Qt：“如果A发生了，就通知B去做C”。
槽函数的执行是触发阶段：当信号被发射时，Qt会检查这个连接。如果发现发送者和接收者不在同一个线程，它就会自动采用一种叫做 Qt::QueuedConnection（队列连接） 的方式。这种方式的核心就是将函数调用封装成一个事件，发送到目标线程的事件队列中，由目标线程的事件循环来执行。

针对你这个 我要问几个问题：

所以 Connect的回调 本质 是有几个 过程？ 是先检查线程嘛？

如果这个函数 本身是在别的线程 但是我又想它在我这个线程 调用 那岂不是就没辙了？



- 答:

- 信号发射： 就是emit

- 查找订阅者： Qt的元对象系统会立刻查找内部的连接表，看看哪些槽函数订阅了这个信号

- 决定投递方式： 系统会遍历 每一个连接好的槽函数 并对每一个连接都进行决策 

  - 根据第五个参数 如果是autoconnect就是 判断一下线程是不是

- 执行投递： 对于直接连接的，不经过任何的中间环节，立即原地执行槽函数，对于队伍连接，将这个函数调用封装成一个QEvent事件，将这个事件放入到接收者所在线程的事件队列的末尾。**`Qt::AutoConnection`**   **`Qt::QueuedConnection`**

- [ ] 11_19





5. 







