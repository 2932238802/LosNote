1. 

virtual 的核心作用是什么？

- 启用多态，当我们将一个成员还能输声明为virtual的时候，编译器会为这个类创建一个虚函数表。
- 这个表是一个函数指针数组
- 粗放这类中所有虚函数的地址
- 每个包含系函数的类的对象，其内存布局中都会增加一个隐藏的虚表指针
- 当通过基类的指针或引用调用虚函数的时候，程序会通过这个指针找到对应的表，并从中调用正确的函数版本
- 这个过程实在运行的时候决定的，因此被称为动态绑定或后期绑定

- [x] 11_19 r

- [ ] 11_19



2. shared_ptr unique_ptr 分别解决了什么问题

- unique_ptr 独占式所有权，一个unique_ptr 指向一个给定的对象，当unique_ptr 本身被销毁的时候，它指向的对象也会被自动删除

- shared_ptr 引用计数的思想，记录由多少个shared_ptr 共同指向该目标

- shared_ptr 解决了多个模块或对象共同管理同一个资源的生命周期的问题

- [ ] 11_19







3. 

unique_ptr 所有权的转移

```c++
#include <memory>
#include <utility> // for std::move

// 创建 unique_ptr
std::unique_ptr<int> ptr1 = std::make_unique<int>(42);

// 转移所有权：ptr1 变为 nullptr，ptr2 获得资源
std::unique_ptr<int> ptr2 = std::move(ptr1);
```

- [x] 11_19
- [ ] 11_19





```c++
void takeOwnership(std::unique_ptr<MyClass> ptr) {
    // 函数获得所有权
    // 函数结束时，ptr 会自动删除资源
}

std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>();
takeOwnership(std::move(ptr)); // 转移所有权给函数
// 此时 ptr == nullptr
```

- [ ] 11_19



```c++
std::unique_ptr<MyClass> createObject() {
    auto ptr = std::make_unique<MyClass>();
    return ptr; // 不需要 std::move，编译器会自动优化
}

void receiveObject() {
    auto obj = createObject(); // 所有权转移
    // obj 拥有资源
}
```

- [ ] 11_19



4. 释放unique_ptr

- 直接赋值 nullptr
- 或者 调用reset函数

- [ ] 11_19





5. 

.cpp 到 可执行文件 中间的四个步骤

- 预处理  由预处理器执行；处理# include define 
- 编译   由编译器执行； 翻译成汇编代码，进行词法分析，语法分析，语义分析和优化
- 汇编  由汇编器执行；翻译成二进制指令，生成目标文件
- 链接  将多个目标文件以及它们所需要的库文件合并在一起，生成最终的可执行文件

- [ ] 11_19













