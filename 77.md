1.   [c++]

sort的前后对比

旧的方式 sort(v.begin(),v.end());

```c++
#include <algorithm> 
#include <vector>

std::vector<int> v = {3, 1, 4, 1, 5, 9};
std::ranges::sort(v); 
```

- [ ] 11_25 支持 C++20的 注意了





2. 

template <class T>
auto Print(){}


如何 实现 传入 可 迭代对象 都可以 打印？

```c++
 // sort 的使用
  vector<int> arr{2, 4, 1, 5, 3};

  std::ranges::sort(arr);

  Print(arr);
  // 默认 从小到大
```





3. [c++]   

sort
如何实现从大 到 小呢
第二个参数 本质是什么 需要传入 什么 ？
是一个 基类对象 所以可以传 std::ranges::greater{}？



- 第二个参数 本质是一个 **可调用对象**

  - 如果你能像函数一样被调用，并且接受两个参数，返回一个布尔值，那你就可以作为我的比较器

  - std::ranges::greater{} 本质上和下面这个一致

  - ```c++
    std::ranges::sort(v, [](int a, int b) { return a > b; });
    ```

```c++ 
vector<int> arr{2, 4, 1, 5, 3};  
std::ranges::sort(arr, std::ranges::greater{});
Print(arr); // 5 4 3 2 1
std::ranges::sort(arr, [](int x, int y) { return x > y; });
Print(arr); // 5 4 3 2 1
```



4. [c++]

对类的处理

![image-20251125102738152](png/image-20251125102738152.png)





5. 

sequenced_policy
parallel_policy
parallel_unsequenced_policy
unsequenced_policy

如何理解？



这四个策略 

是传递给 算法 的第一个参数

用来告诉 编译器 你允许它 以何种方式 来并行化或优化这个算法的执行



ai 给的

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <execution> // 必须包含这个头文件

void process(int& n) {
    // 假设这是一个耗时的独立计算
    n = (n * n) % 1000; 
}

int main() {
    std::vector<int> v(10000000, 123);

    // 1. 传统顺序执行
    std::for_each(v.begin(), v.end(), process);

    // 2. C++17 顺序策略 (效果同上)
    std::for_each(std::execution::seq, v.begin(), v.end(), process);

    // 3. 并行策略 (利用多核CPU)
    std::for_each(std::execution::par, v.begin(), v.end(), process);

    // 4. 并行+无序策略 (利用多核CPU和向量化)
    //    前提是 process 函数足够简单，没有锁等副作用
    std::for_each(std::execution::par_unseq, v.begin(), v.end(), process);

    return 0;
}

```





































