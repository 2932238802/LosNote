1. const auto&   和  auto&& 项目

```c++
int x = 10;
const auto& a = x; 
auto&&      b = x; 
const auto& c = 5; 
auto&&      d = 5;
```

- const auto&  无论绑定左值还是右值  结果始终是const T&
- auto&& 是万能引用 可能是 T& 也可能是 T &&
- auto&& 可以配合 std::forward 保留值类别 
- auto&& 可以区分是左值还是右值 并转发出去
- const auto& 左值 就 绑定为 const T& ; 右值 就绑定为 const T& 并演唱临时对象的生命周期
- auto&& 左值 推导为 T&  右值 推导为 T&&
- const auto& 引用绑定，不会产生拷贝
- auto&& 也是引用绑定 同样不产生拷贝

- [x] 11_17

- [ ] 



2. 
```c++
int main()
{
  std::vector<std::string> contain;
  auto f1 = [&contain](auto &&...args)
  { contain.emplace_back(std::forward<decltype(args)>(args)...); };

  f1("你好");

  for (const auto &a : contain)
  {
    std::cout << a << " ";
  }
  std::cout << std::endl;

  return 0;
}
```

```shell
losangelous@LosAngelous:~/LosAngelous/Project/test$ ./run2
你好 
```


```c++
int main()
{

  std::vector<std::string> contain;

  auto f1 = [&contain](auto &&...args)
  { (contain.emplace_back(std::forward<decltype(args)>(args)), ...); };

  f1("你好", "不是", "hello", "world");

  for (const auto &a : contain)
  {
    std::cout << a << " ";
  }
  std::cout << std::endl;

  return 0;
}

```

```shell
losangelous@LosAngelous:~/LosAngelous/Project/test$ ./run2
你好 不是 hello world 
```


- 理解:


  - ```c++
    contain.emplace_back(std::forward<decltype(args)>(args)...);
    ```
  - ```c++
    func( something(args)... );
    ```
	
  - ```c++
    func(args...);                 // 展开成 func(arg0, arg1, arg2, ...)
	func(std::forward<T>(args)...);// 展开成 func(forward(arg0), 			forward(arg1), ...)
    ```
  - 


```c++
int main()
{

  std::vector<std::string> contain;

  auto f1 = [&contain](auto &&...args)
  { contain.emplace_back(std::forward<decltype(args)>(args)...); };

  std::string s("hello wolrd");
  f1(s.begin(), s.end());

  for (const auto &a : contain)
  {
    std::cout << a << " ";
  }
  std::cout << std::endl;

  return 0;
}

```

```shell
losangelous@LosAngelous:~/LosAngelous/Project/test$ ./run2
hello wolrd 
```

- 理解：
  -  只要能够 构造 string 就都可以





3. 捕获的值也可以进行初始化 可以是定义了 也可以是没有定义的

```C++
int main()
{

  int x = 10;

  auto lumda1 = [y = x * 2]()
  { std::cout << "y = x * 2 " << " 所以y的值是: " << y; };

  lumda1();
  return 0;
}
```
```shell
losangelous@LosAngelous:~/LosAngelous/Project/test$ ./run2
y = x * 2  所以y的值是: 20
```

```c++
int main()
{

  int x = 10;
  const int z = 20;
  auto lumda1 = [y = x * 2, z = 3]()
  {
    std::cout << "z 的 值是: " << z << std::endl;
    std::cout << "y = x * 2 " << " 所以y的值是: " << y;
  };

  lumda1();
  return 0;
}
```

```shell
losangelous@LosAngelous:~/LosAngelous/Project/test$ ./run2
z 的 值是: 3
y = x * 2  所以y的值是: 20
```

- 注意这里z 和 顶层的z 已经没有关系了 可以理解为:
  ```c++ 
	  struct 匿名Lambda {
    int y;
    int z;
    void operator()() const {
    std::cout << "z 的 值是: " << z << std::endl;
    std::cout << "y = x * 2 " << " 所以y的值是: " << y;
    }
    };
    auto lambda1 = 匿名Lambda{ x * 2, 3 }; 
  ```



4. 

is_integral_v?
如何理解这个用法

答:

- ```c++
  template<class T>
  inline constexpr bool is_integral_v = std::is_integral<T>::value;
  ```

- 
```c++
std::is_integral_v<T>   // 等价于 std::is_integral<T>::value
```

- 

5. 

```c++
int main()
{

  int x = 100'000;

  std::cout << x << " " << std::endl;

  return 0;
}
```

```she
losangelous@LosAngelous:~/LosAngelous/Project/test$ ./run2
100000 
```









