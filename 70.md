1. [Go]

go get -u github.com/gin-gonic/gin 

go get -u gorm.io/gorm 

go get -u gorm.io/driver/sqlite

- 分别是 最流的 http 库
- 负责对象关系的映射
- 和 一个 sqlite





2. [Go]

这样一个一个 指令 安装过去 我觉得 太慢了 
有没有 一个 类似 requerements.txt 这样一个文件 直接 一键 安装完毕？

答: 没有 这样一个文件





3. [Go]

`fmt.Println()` 会自动在多个参数之间添加空格



4. [Go]

go handleRequest(conn)
这样一句
是不是 就是 非阻塞 还是 创建子进程 还是 父进程？

答： 不是 是携程



5. 

请你 详细给我讲解一下 携程
最好是从计算机组成 比较底层和我讲一下
线程 进程 和 携程

我有点晕了
你的意思是假设 进程 是 A 那么 A 里面就有 (B,C,D)的线程然后 BCD 分别有(b1,b2)(c1,c2)(d1,d2)的线程？
这是一点

还有 这些 BCD都存在 哪个位置 难道是 分割A的堆区？
还有 b1 b2 c1 c2 d1 d2 也是 分割 BCD的堆？



答：

进程是最大的容器

线程是 直接属于进程 A的

- [x] 11_22
- [ ] 



问：

我有点晕了
你的意思是假设 进程 是 A 那么 A 里面就有 (B,C,D)的线程然后 BCD 分别有(b1,b2)(c1,c2)(d1,d2)的线程？
这是一点

还有 这些 BCD都存在 哪个位置 难道是 分割A的堆区？
还有 b1 b2 c1 c2 d1 d2 也是 分割 BCD的堆？



答：

- 协程调度是用户态程序（模拟出来的一套微型调度系统

- 内核没有携程调度

- [ ] 11_22



问：

所以 携程 是C++或者Go 编译器 
自己实现好的内部 的 一种管理机制对么

那为什么 都有多线程了 还需要携程呢？ 意义在哪?
或者说 携程这么好用 那为啥还需要多线程？



答：

- 高级语言的编译器和运行的时候，在线程的基础上，构建了携程这个更高级更轻量的并发模型
- 负责管理携程的栈 保存和恢复上下文，以及决定何时切换（调度）
- 线程的意义： 携程是用户态的概念，它必须运行在一个或多个操作系统的线程之上，如果没有线程，携程就是无根之木
  - 如果你的线程只有一个线程，那么多少个线程都只能在这个线程上进行并发，分时复用
  - 任意时刻 只有一个携程在真正运行

- 内存成本上面 线程 太昂贵 2MB 或者 8MB
- 而携程 2KB 是在堆上分配的 可以按需增长 不会浪费
- 调度成本
  - 并发编程噩梦 来自于 共享内存

- [ ] 11_22



问：

如何理解 线程切换 要从用户态到内核态





答：

线程切换的完整版本

假设现在 CPU 正在用户态 (Ring 3) 执行线程 A 的代码
这时，线程 A 的时间片用完了，操作系统决定要切换到线程 B

**第一幕：从用户态到内核态 (陷入)**

1. 时钟中断 (Timer Interrupt): CPU 内部的时钟硬件产生一个中断信号。
2. 保存断点: CPU 立即暂停线程 A 的执行。它自动把当前的程序计数器 (PC) 和一些关键寄存器的值压入一个特殊的内核栈
3. 切换到 Ring 0: CPU 的模式位被设置为内核态。
4. 跳转到中断处理程序: PC 指针被强制跳转到操作系统内核中预设好的一段代码地址——时钟中断处理程序。

至此，CPU 的控制权已经从你的应用程序，完全交给了操作系统内核。

**第二幕：在内核态进行调度**

1. 内核代码执行: 现在 CPU 正在 Ring 0 执行内核代码。
2. 更新线程状态: 内核发现线程 A 的时间片已用尽，于是更新线程 A 的线程控制块 (TCB)，将其状态标记为“就绪 (Ready)”
3. 保存完整上下文: 内核需要把线程 A 在用户态运行时的所有寄存器（通用寄存器、浮点寄存器等）的值，全部复制并保存到线程 A 的 TCB 结构体里。这是一个内存拷贝操作
4. 调用调度器 (Scheduler): 内核的调度算法开始运行，它从“就绪队列”中挑选出下一个要运行的线程，比如选中了线程 B
5. 切换内存上下文 (如果是跨进程切换): 如果线程 B 属于另一个进程，内核还需要切换页表，刷新 TLB（这是最耗时的部分，但同进程内线程切换不需要这一步）

**第三幕：从内核态返回用户态 (恢复)**

1. 加载新线程上下文: 内核从线程 B 的 TCB 中，读取之前保存的所有寄存器值。
2. 恢复寄存器: 内核把这些值加载回 CPU 的物理寄存器中
3. 切换回 Ring 3: 内核执行一条特殊的指令（如 `IRET`），这条指令会：
   - 将 CPU 的模式位设置回用户态
   - 从内核栈中弹出之前保存的 PC 值，恢复到 PC 寄存器
4. 执行新线程: CPU 开始执行线程 B 的代码，从它上次被中断的地方继续

