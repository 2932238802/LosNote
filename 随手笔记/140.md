1. [c++]

- **什么是内存对齐（Memory Alignment）？为什么引擎开发中非常看重它？**
  - **回答要点**：
    - CPU 访问内存是按块（如4或8字节）读取的，对齐可以减少 CPU 访问内存的次数

- [x] 26_1_28





2. [c++]

- 单调栈（Monotonic Stack）是一种非常特殊的数据结构，它的面试出镜率极高。

  简单一句话总结：**当你需要为数组中的每个元素，寻找左边或右边“第一个比它大”或“第一个比它小”的元素时，由于这涉及“寻找邻居边界”的比较，单调栈就是标准答案**

- [x] 26_1_28



3. 

为什么按照声明顺序而不是初始化列表顺序？从设计者的角度考虑为什么这么设计

为什么？



- **销毁（析构）对象的顺序必须是构造顺序的完全逆序**

- 防止潜在的“隐式依赖”崩溃

- 我需要唯一的析构函数 →→
- 我需要唯一的逆序销毁顺序 →→
- 我必须有唯一的正序构造顺序 →→
- 初始化列表可能有多个且乱序，不可信 →→
- **只有类声明里的顺序是唯一的，就选它了**

- [ ] 26_1_29



4. [c++] 手撕栈

```c++
#include <iostream>
#include <stdexcept>
#include <algorithm>

template <typename T>
class MyStack {
private:
    T* data;          
    size_t capacity;  
    size_t topIdx;   

    void reserve(size_t newCapacity) {
        if (newCapacity <= capacity) return;
        
        T* newData = new T[newCapacity];
        for (size_t i = 0; i < topIdx; ++i) {
            newData[i] = std::move(data[i]); 
        }
        
        delete[] data;  
        data = newData;
        capacity = newCapacity;
    }

public:
    MyStack(size_t initCapacity = 10) 
        : data(new T[initCapacity]), capacity(initCapacity), topIdx(0) {}

    ~MyStack() {
        delete[] data;
    }

    MyStack(const MyStack&) = delete;
    MyStack& operator=(const MyStack&) = delete;

    void push(const T& val) {
        if (topIdx == capacity) {
            reserve(capacity == 0 ? 1 : capacity * 2);
        }
        data[topIdx++] = val;
    }

    void pop() {
        if (empty()) {
            throw std::out_of_range("Stack<>::pop(): empty stack");
        }
        --topIdx; 
    }

    T& top() {
        if (empty()) {
            throw std::out_of_range("Stack<>::top(): empty stack");
        }
        return data[topIdx - 1];
    }

    const T& top() const {
        if (empty()) {
            throw std::out_of_range("Stack<>::top(): empty stack");
        }
        return data[topIdx - 1];
    }

    bool empty() const { return topIdx == 0; }
    size_t size() const { return topIdx; }
};
```

- [x] 26_1_28 



5. [c++] 手撕队列

```c++
#include <iostream>
#include <stdexcept>

template <typename T>
class MyQueue {
private:
    struct Node {
        T data;
        Node* next;
        Node(const T& val) : data(val), next(nullptr) {}
    };

    Node* head; 
    Node* tail;  
    size_t count;

public:
    MyQueue() : head(nullptr), tail(nullptr), count(0) {}

    ~MyQueue() {
        while (!empty()) {
            pop();
        }
    }

    MyQueue(const MyQueue&) = delete;
    MyQueue& operator=(const MyQueue&) = delete;

    void push(const T& val) {
        Node* newNode = new Node(val);
        if (empty()) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
        count++;
    }

    void pop() {
        if (empty()) {
            throw std::out_of_range("Queue is empty");
        }
        Node* temp = head;
        head = head->next;
        delete temp;
        
        count--;
        if (count == 0) {
            tail = nullptr;
        }
    }

    T& front() {
        if (empty()) {
            throw std::out_of_range("Queue is empty");
        }
        return head->data;
    }

    const T& front() const {
        if (empty()) {
            throw std::out_of_range("Queue is empty");
        }
        return head->data;
    }

    bool empty() const { return count == 0; }
    size_t size() const { return count; }
};

```







类中的成员类实例存储在栈上还是在堆上？

![image-20260128210250701](D:\LosAngelous\LosNote\随手笔记\png\image-20260128210250701.png)

- [x] 26_1_29
