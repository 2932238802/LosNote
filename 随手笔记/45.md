1. 几个问题
   inline 和 constexpr的区别和使用场景？

- inline
  - 解决多重定义的问题 如果多个.cpp文件各自定义一份 会连接错误 加上inline之后 允许多个翻译单元
    有相同的定义,链接器会把它们视为同一个实体
  - 主要是连接层面的修饰符好,允许多个翻译单元重复定义(前提是定义是一致的)
  - 使用场景: 
    - 头文件里面定义全局变量
    - 头文件里面定义小的函数
    - 包括变量模板
- constexpr
  - 在编译期间就能求值的常量和函数(满足一定的条件)
  - 使用场景
    - 编译期计算
    - 作为数组大小等需要编译器常量的地方

- [ ] 11_17

- [ ] 11_19

  

2. 


```c++
template <class T> constexpr bool is_const_v = std::is_const<T>::value;

template <class T> constexpr bool is_const_v = std::is_const<T>();？
```

问:
如何理解 
is_const?
是这样写的嘛？

```c++
template <class T> constexpr bool is_const_v = std::is_const<T>::value;
```

答:
```c++
template <class T> inline constexpr bool is_const_v = std::is_const<T>::value;
int main()
{
  std::cout << is_const_v<const int> << std::endl; // 输出1
  return 0;
}
```

- [ ] 11_19




3. C++14 允许 lumbda 表达式使用auto 作为参数类型
使其成为泛型.

auto& 表示左值 引用
auto&& 代表万能 引用
auto&&... 达标可变模板参数的万能引用

```c++
int main()
{
  auto grete = [](const auto &left, const auto &right) { return left > right; };
  std::cout << grete(5, 3) << std::endl;                          // 1
  std::cout << grete(std::string("hello"), std::string("world")); // 0
  return 0;
}
```

- [ ] 11_19



4.  智能指针 shared_ptr

答: 多个shared_ptr 可以共同使用同一块堆内存。并且，由于该类型智能指针在是线上采用的是引用计数机制，即使有一个shared_ptr 指针放弃了堆内存的“使用权”，也不会影响其它指向同一堆内存的shared_ptr 指针 

只有引用计数为0的时候，堆内存才会被自动释放

- [ ] 11_19



5. 















