1. [rust]

- 暂停 3 秒

thread::sleep(Duration::from_secs(3));

- [x] 26_1_25



2. [ps]

taskkill /f /t /im 你的程序名.exe

- 可以直接 杀死 进程

- [x] 26_1_25



taskkill /f /t /im 这几个 / 是什么意思

- /f 是强制
- /t 是进程树
- /im 是印象名称
  - 指定要终止的进程的**文件名**

- [x] 26_1_25







| **/f**  | **Force**      | 强制     | 不听废话，直接杀掉     |
| ------- | -------------- | -------- | ---------------------- |
| **/t**  | **Tree**       | 进程树   | 斩草除根（包括子进程） |
| **/im** | **Image Name** | 映像名称 | 根据“名字”来找目标     |

- [ ] 26_1_25







3. [rust]

```rust
async fn audit_layer(req: Request, next: Next) -> Response {
    let start = Instant::now();
    let method = req.method().clone();
    let path = req.uri().path().to_string();
    let ip = req.headers().get("x-forwarded-for")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("unknown")
        .to_string();

    let response = next.run(req).await;

    let duration = start.elapsed();
    println!(
        "[Audit] IP: {}, Method: {}, Path: {}, Status: {}, Latency: {:?}",
        ip, method, path, response.status(), duration
    );
    
    response
}
```



这个 函数里面的 
    let ip = req.headers().get("x-forwarded-for")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("unknown")
        .to_string();
如何理解？
如何理解 可以这样递归操作
如何理解 and_then?
如何理解 unwrap_or ?

- headers().get("...")

  - 这个是 去 headers 里面去取 x-forwarded-for 一般是 真实的ip

- and_then

  - **如果我有值，就执 行下一步操作；如果我已经是 `None` 了，就直接跳过，保持 `None`**

- unwrap_or
  - 如果是 None就给个默认值   "unknown"

- [x] 26_1_25



unwrap_or
这个 括号 里面填什么值
完全 取决于  这个 ip 
需要什么 值 对么

- 对!

- [x] 26_1_25



4. 

```rust
use axum::{
    extract::{Request, State},
    http::StatusCode,
    middleware::{self, Next},
    response::Response,
    routing::post,
    Router,
    Json,
};
```

如何理解 
这个   middleware::{self, Next},？

- self 这个有了 之后 就可以调用 middleware 的 静态函数了

- [x] 26_1_23







也就是说 
如果 这个 middleware::from_fn 能转换 那么 这个 函数必须含有 这个 next: Next这个参数对么？
同时也必须 有这么 两行对么
let response = next.run(req).await; // 使用 Next 让请求继续传递
response



- **是的，必须包含 `Next` 参数，且通常需要执行并返回 `next.run` 的结果**
- 你最后提到的 `response` 返回也是必须的。 中间件的本质是：**接收一个 Request，最后返回一个 Response**

- [x] 1-23



- 要让 `middleware::from_fn` 正常工作：
  1. **参数列表**：必须有 `req: Request` 和 `next: Next`（顺序不分先后，还可以加入 `State` 等提取器）。
  2. **通行**：如果你想让程序继续运行，**必须**执行 `let response = next.run(req).await;`。
  3. **拦截**：如果你想拒绝访问，就**不要**调用 `next.run`，而是直接返回一个错误响应（如 `StatusCode::FORBIDDEN`）。
  4. **返回**：最后必须返回一个 `Response` 对象

- [x] 1_23



5.  [rust]

async fn relay_handler(Json(payload): Json<Value>) -> (StatusCode, Json<Value>) {
    // 这里执行整形
    let transformed = reshape_data(payload);
    

    // 模拟转发到 B 平台 (实际中这里会用 reqwest 发送请求)
    println!("Forwarding to Target B: {}", transformed);
    
    (StatusCode::OK, Json(json!({"status": "success"})))
}

这个 函数 头里面 
为什么 参数 名字可以是 Json(payload)？不应该是 payload:: Json<Value>



- ```rust
  async fn handler(data: Json<Value>) {
      // data 的类型是 Json<Value>
      // 如果你想拿到里面的 Value，你需要写 data.0
      let val = data.0; 
  }
  
  ```

  - 这个是 普通的写法

- ```rust
  async fn handler(Json(payload): Json<Value>) {
      // payload 的类型直接就是 Value
      // 因为 Json( ) 这个“壳”在参数位置就被拆开了
      println!("{}", payload); 
  }
  
  ```

  - 这个是解构的写法





- [x] 26_1_25



