1. 

```rust
let input_ndarray: Array4<f32> = Array4::from_shape_fn((1, 1, 28, 28), |(_, _, y, x)| {
        let pixel = gray_img.get_pixel(x as u32, y as u32)[0];
        pixel as f32 / 255.0
    });

这个 代码的
这个  gray_img.get_pixel(x as u32, y as u32)[0]; 这个 0 是什么意思？
```



- 在 `image` 库中，无论图片是彩色的还是黑白的，一个像素都被视为一组数据的集合
- Lumu 只有一个值 也就是 第一个就是亮度





---





2. 

axum
这个是 rust的什么库？

- 异步web 框架

- [x] 1_20





---





3. [rust]

serde这个呢？

- 用于序列化和反序列化的核心框架

serde_json呢？

- 它是 **Serde 框架针对 JSON 数据格式的具体实现**

reqwest

- **`reqwest`** 是 Rust 中最流行的**异步 HTTP 客户端库**

`sqlx` 和 `dotenv` 这两个库。它们在实际项目中一个管数据库，一个管配置，都非常常用





---





4. [rust]

```rust
let app = Router::new().route(path, method_router)

如何理解这个 Router::new()？
```



- 初始化了 一个 空的哈希表 或 树形结构
- 抵用这个route 其实就是往 这个结构里面插入数据





---







5. [rust]

    ok
    1. method_router 这个是一个怎么样的函数 函数签名是？
    2. get是不是也是一个函数？
    3. 如果我要把这个函数封装可以怎么写？


- 第二个参数 不是 函数

  - 是 axum::routing::MethodRouter
  - 是结构体
  - .route("/user", get(get_user).post(create_user))
  - *对于这个路径（比如* `/user`*），如果是* **GET** *请求，我交给 A 函数处理；如果是* **POST** *请求，我交给 B 函数处理*

- get 是一个函数工厂

  - 作用： **把你的业务函数（Handler），包装成一个 `MethodRouter` 对象**

- ```rust
  use axum::Router;
  mod assets; // 引入上面的模块
  
  #[tokio::main]
  async fn main() {
      // 像拼积木一样把它们拼起来
      let app = Router::new()
          // 1. 注册首页
          .route("/", axum::routing::get(|| async { "Home" }))
          
          // 2. 挂载 assets 模块
          // 这里的 .nest 意思是：凡是以 "/api/assets" 开头的请求，
          // 都转交给 assets_routes() 返回的那个 Router 处理。
          // 所以访问路径变成了：/api/assets/list
          .nest("/api/assets", assets::assets_routes());
  
      // ... 启动服务逻辑 ...
      let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
      axum::serve(listener, app).await.unwrap();
  }
  
  ```



    1. 所以get和post都是函数工厂？
    2. 且喂给它们的函数签名是   async fn A() {}对么？
    3. 如何理解  &'static str 这写法？
    4. rust的lumbda表达式怎么写？
- 都是函数工厂
- 你不需要死记硬背签名，你需要什么参数就写在括号里，你想返回什么就写在箭头后面，Axum 会想办法适配
- 这一辈子都死不掉的字符串引用 就是  &'static str
- 这就做 闭包
- ```rust
  let add = |a, b| a + b;
  println!("{}", add(1, 2));
  
  .route("/", get(|| async { 
      "Hello, World!" 
  }))













