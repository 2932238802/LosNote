1.  [Qt C++]

如何 判断一个字符串是 全路径还是文件？

```c++

/// <summary>
/// 26_2_12
/// - 如果是 完整的文件名字
/// - 就返回true
/// - 否则是拼装过的 就返回
/// </summary>
/// <param name="str"></param>
/// <returns></returns>
inline auto getFullName(const QString& str) -> decltype
{
	if (QDir::isAbsolutePath(str))
	{
		return { true,str };
	}

	str = QCoreApplication::applicationDirPath() + "/" + str;
	return { false,str };
}

这样不行么
```



- ```c++
  inline QPair<bool, QString> getFullName(const QString& str) 
  {
      if (QDir::isAbsolutePath(str))
      {
          return { true, str };
      }
  
      // 注意：不要修改原参数 str，创建一个新变量
      QString absolutePath = QDir::cleanPath(QCoreApplication::applicationDirPath() + "/" + str);
      return { false, absolutePath };
  }
  ```





2. 

QPointer
详细介绍一下



- 在所有权上 std::unique_ptr是独占 所有权的
  - 它能保证同一时间只有一个指针拥有该对象
- 但是 QPointer<T> 是自动设置为nullptr
  - 没有所有权

- [x] 26_2_12



```c++
	// 更新全局状态数据
	connect(ui->lblUserAvatar, &UI::UserAvatar::_localImagechoosed, this, [=]
		(bool isSuc, const QString& msg, const QString& filePath) {

			Net::UploadAvatarRequest* request = new Net::UploadAvatarRequest(
				filePath,
				LOS_state->userId()
			);
			Net::NetManage::getInstance().sendRequest(request);
	});


这里 是 本地设置好了图片
我想要 远程 仓库 返回表示ok的时候 再去更新LOS_state如何操作呢
```



```c++
	connect(ui->lblUserAvatar, &UI::UserAvatar::_localImagechoosed, this, [=]
		(bool isSuc, const QString& msg, const QString& filePath) {

			Net::UploadAvatarRequest* request = new Net::UploadAvatarRequest(
				filePath,
				LOS_state->userId()
			);

			connect(request, &Net::UploadAvatarRequest::_uploadfinish, this, [this](
				bool isOk , const QString & msg , const QString filename){
					if (isOk)
					{

					QString filePath = Com::getFullName(filename).second;
					LOS_state->setAvatarPath(filePath);
					}

					else {
						LOGE() << "sth wrong: " << msg;
					}
			});

			Net::NetManage::getInstance().sendRequest(request);
	});
```





3. 

QDir 如何打印?

- 可以直接打印 Qt 重载了对这个的支持





4. 

```c++
#include <QApplication>
#include <QEventLoop>
#include <QSplashScreen> 
#include "mainwindow.h"
#include "ui/LoginDialog/LoginDialog.h"
#include "common/AuthState.h"
#include "common/logger.h"
#include "net/AutoLoginRequest.h"
#include "net/NetManage.h"

int main(int argc, char* argv[])
{
    std::freopen("app.log", "a", stderr);
    QApplication a(argc, argv);
    Com::init();

    Com::AuthState *state = new Com::AuthState(&a);
    bool autoLoginSuccess = false;

    // 1. 如果本地有 Token，尝试自动登录
    if (state->isLogin()) {
        LOGI() << "Detected local token, attempting auto-login...";
        QEventLoop loop;
        Net::AutoLoginRequest* req = new Net::AutoLoginRequest(state->userId(), state->token());
    
        // 监听登录结果
        QObject::connect(req, &Net::AutoLoginRequest::_autoLoginFinished, 
            [&](bool isSuc, const QString& msg, UserData data) {
                if (isSuc) {
                    LOGI() << "Auto-login success!";
                    // 更新本地状态
                    state->login(data.id, state->token(), data.username, data.avatar);
                    autoLoginSuccess = true;
                } else {
                    LOGW() << "Auto-login failed: " << msg;
                    state->logout(); // 登录失败清空过期的 Token
                    autoLoginSuccess = false;
                }
                loop.quit(); // 退出事件循环
            });

        // 发送请求 (假设 NetManage 有单例或静态方法)
        Net::NetManage::instance()->sendRequest(req);

        // 设置超时处理：如果 5 秒没反应，直接进登录界面，防止卡死
        QTimer::singleShot(5000, &loop, &QEventLoop::quit);

        loop.exec(); 
    }


    if (autoLoginSuccess) {
        MainWindow* w = new MainWindow(state);
        w->show();
        return a.exec();
    } else {

        LoginDialog log(state);
        if (log.exec() == QDialog::Accepted) {
            MainWindow* w = new MainWindow(state);
            w->show();
            return a.exec();
        }
    }

    return 0;
}

```



```c++
几个问题 
1. QObject::connect 为什么只有三个参数
2. QEventLoop loop 局部声明的意义是?
```



- connect的四种写法

  - ```c++
    connect(
        sender,           // 1. 发送者
        &Sender::signal,  // 2. 信号
        receiver,         // 3. 接收者 (对象指针)
        &Receiver::slot   // 4. 处理函数 (槽函数)
    );
    ```

  - ```c++
    connect(
        sender,           // 1. 发送者
        &Sender::signal,  // 2. 信号
        [](){ ... }       // 3. 处理函数 (Lambda 表达式)
    );
    ```

  - ```c++
    connect(
        sender,           // 1. 发送者
        &Sender::signal,  // 2. 信号 (上下文/接收者)
        this,             // 3. 接收者 (即便后面是 Lambda，也要指定谁在听)
        [this](){ ... }   // 4. 处理函数 (Lambda 表达式)
    );
    ```

- loop 是在不阻塞操作系统事件的前提下，把异步代码变成同步流程

- 具体 可以 看 代码



5. [c++ Qt]

```c++
setAttribute和setWindowFlag
作用的领域是?
```

- setAttribute是对内的  属性

- setWindowFlag 是对外的 标志





