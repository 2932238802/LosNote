1. [rust]

在 AI 识别数字（MNIST）时，模型要求的输入通常是一个 **4 维数组**，形状是： `[1, 1, 28, 28]`

这四个数字分别代表：

1. **Batch Size（批大小）**: `1` —— 每次只识别 1 张图。
2. **Channels（通道数）**: `1` —— 灰度图只有 1 个颜色通道。
3. **Height（高度）**: `28` —— 28 像素。
4. **Width（宽度）**: `28` —— 28 像素



- [ ] 1_20



2. [rust]

如何 理解from_shape_fn

```rust
Array4::from_shape_fn(形状, |坐标| { 
    // 根据坐标计算出这个位置该填什么值
})
```



- 强大且优雅的构造函数



```rust
use ndarray::Array2;

let matrix = Array2::from_shape_fn((3, 3), |(y, x)| {
    (y + x) as f32
});

// 生成的结果：
// [0, 1, 2]
// [1, 2, 3]
// [2, 3, 4]
```





3. [rust]

```rust
fn main(){

    let matric = Array2::from_shape_fn((3,3), |(y,x)|{
        (y+x) as f32
    });

    println!("{}",matric);
//  [[0, 1, 2],
//  [1, 2, 3],
//  [2, 3, 4]]
}
```

- [x] 1_20 







4. 

image (像素) -> ndarray (数学矩阵) -> tract (AI 张量)。
let nd_array = Array4::from_shape_fn(...); // 返回 Array4<f32>
let tensor = Tensor::from(nd_array); 

对于 以上我有几个问题：
1. 这几个库不都是独立开发的么？
2. 难道是 tract 特意去实现了一个 Tensor::from的接口 去处理 这个 Array(image)?



为什么 `Tensor::from(nd_array)` 能工作？（重点）
这涉及到 Rust 的一个核心设计模式：**`From` 和 `Into` Trait（接口）**，以及 **Feature Flags（特性开关）**。
A. 谁实现了接口？
确实是 **`tract` 的作者主动去适配了 `ndarray`**。
B. 为什么 `tract` 要这么做？
因为 `ndarray` 实际上已经成为了 Rust 科学计算的**事实标准**。 就像所有的手机充电器都会去做 USB-C 接口一样，如果一个 AI 推理库不支持 `ndarray`，那么开发者用起来会非常痛苦。为了让大家愿意用自己的库，`tract` 的作者决定：“我要写一段代码，只要别人给我一个 `ndarray`，我就能自动把它变成我的 `Tensor`。”



- [ ] 1_20



5 .

```
let model = tract_onnx::onnx()
        .model_for_path("mnist-8.onnx")?
        .with_input_fact(0, f32::fact(&[1, 1, 28, 28]).into())?
        .into_optimized()?
        .into_runnable()?;
```

- 初始化 ONNX 格式的读取器

- `.model_for_path("mnist-8.onnx")?`

- .with_input_fact(0, f32::fact(&[1, 1, 28, 28]).into())?

- .into_runnable()? 
  - 这个是 编译成 可 执行对象
















