1. ubuntu 安装 sqlite

```shel
sudo apt update
sudo apt install sqlite3 -y
```



2.  包含 aiso的vcpkg的集成

  find_package(asio CONFIG REQUIRED)
  target_link_libraries(main PRIVATE asio::asio)

- [ ] 11_26
- [ ] 



3. dnf 也是一个软件安装工具

4.  gtest的测试下面
```c++
losangelous@LosAngelous:~/LosAngelous/Project/LosMq$ make run
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from case1
[ RUN      ] case1.add
[       OK ] case1.add (0 ms)
[----------] 1 test from case1 (0 ms total)

[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran. (0 ms total)
[  PASSED  ] 1 test.

如何理解这个输出结果

#include <gtest/gtest.h>
#include <iostream>

int add(int x, int y)
{
    return x + y;
}

TEST(case1, add)
{
    EXPECT_EQ(add(2, 3), 5);
}

int main(int argc, char* argv[])
{
    testing::InitGoogleTest(&argc, argv);
    RUN_ALL_TESTS();
    return 0;
}

如何理解这个代码
以及case1
如果我要单方面测试一个呢？
```

TEST  是一个宏 用来定义一个测试用例

第一个参数是 测试套件的名称(TEST SUITE) 

第二个参数是测试用例的名称

可以通过 :

./mytest --gtest_filter=case1.add

./mytest --gtest_filter=case1.*

等方式进行测试

5.  
```c++
// server.cc
#include <iostream>
#include <string>
#include <asio.hpp>

// 使用 asio 的命名空间，简化代码
using asio::ip::tcp;

int main()
{
    try
    {
        // 1. 创建 asio 的 I/O 上下文
        //    所有 asio 程序都必须有一个 io_context 对象
        asio::io_context io_context;

        // 2. 创建一个 acceptor 用于监听连接
        //    - 监听在 IPv4 上 (tcp::v4())
        //    - 端口号是 12345
        tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), 12345));

        std::cout << "Server started, listening on port 12345..." << std::endl;

        // 3. 无限循环，等待并处理客户端连接
        for (;;)
        {
            // 4. 创建一个 socket 对象
            //    这个 socket 将用于与连接成功的客户端进行通信
            tcp::socket socket(io_context);

            // 5. 等待客户端连接 (阻塞)
            //    程序会在这里暂停，直到有一个客户端连接进来
            acceptor.accept(socket);

            // 当有客户端连接后，打印客户端的 IP 地址和端口
            std::cout << "Client connected from: " << socket.remote_endpoint() << std::endl;

            // 6. 与客户端持续通信，直到客户端断开或发生错误
            for (;;)
            {
                // 7. 准备一个缓冲区用于接收数据
                std::array<char, 1024> data;
                asio::error_code error;

                // 8. 从 socket 读取数据 (阻塞)
                //    read_some 会在收到数据后返回，或者在出错/断开时返回
                size_t length = socket.read_some(asio::buffer(data), error);

                // 9. 检查是否发生错误
                if (error == asio::error::eof)
                {
                    // 客户端主动断开连接
                    std::cout << "Client disconnected." << std::endl;
                    break; // 跳出内部循环，等待下一个客户端连接
                }
                else if (error)
                {
                    // 发生了其他错误
                    throw asio::system_error(error);
                }

                // 10. 将收到的数据原封不动地写回 socket (回声)
                std::cout << "Received: " << std::string(data.data(), length);
                asio::write(socket, asio::buffer(data, length));
            }
        }
    }
    catch (std::exception& e)
    {
        std::cerr << "Exception: " << e.what() << std::endl;
    }

    return 0;
}

```

如何理解 asio::write(socket, asio::buffer(data, length));

- asio::write 动作就是发送
- socket 就是目的地 通过哪个通道进行发送
- asio::buffer(date,length) 就是发送什么 以及 发送多少
- 保证将 data 缓冲区 从开头到length长度 的全部字节 都通过socket这个网络连接通道完整地发送给对方
- asio::buffer 记录两个一个是data的起始地址 然后就是这个长度
- 





