1. 工厂模式

```c++
#include <iostream>
#include <string_view>

class project {

public:
  virtual void show() = 0;
  virtual ~project() = default;
};

class projectA : public project {

public:
  void show() override { std::cout << 'a' << std::endl; }
};

class projectB : public project {
public:
  void show() override { std::cout << 'b' << std::endl; };
};

class Fac {
public:
  static project *getProject(std::string_view type) {
    if (type == "a") {
      return new projectA();
    } else if (type == "b") {
      return new projectB();
    }
    return nullptr;
  }
};

int main() {

  project *pro = Fac::getProject("a");
  pro->show();
  return 0;
}
```

1. **虚析构函数**我在基类中定义了虚析构函数，这是为了防止在多态环境下，通过基类指针删除派生类对象时发生内存泄漏。”
2. **纯虚函数**：“我将 `show()` 定义为纯虚函数，这样 `project` 就变成了抽象基类，防止被误实例化，同时也强制子类必须实现该接口。”
3. **智能指针**：“在工厂模式中，我推荐返回 `std::unique_ptr`。因为工厂模式将创建对象的权利交给了外部，使用智能指针可以明确**所有权转移**，并避免手动 `delete` 遗漏导致的内存泄漏。”
4. **string_view**：“我使用了 C++17 的 `string_view` 作为参数，它避免了不必要的字符串拷贝，提升了传递效率。

- [ ] 26_1_30





2. [c++]

string_view 和 传入 const string& 的区别？



- **`const std::string&`**：如果你传入一个字符串字面量（比如 `"hello"`），编译器必须先构造一个**临时的 `std::string` 对象**，这可能会触发堆内存分配（Heap Allocation）。
- **`std::string_view`**：它只是一个**“视图”**（内部就是一个 `char*` 指针 + 一个 `size_t` 长度）。当你传入 `"hello"` 时，它直接指向这块常量区，**没有任何内存分配开销**

- [x] 26_1_30



- 子串处理方面

- **`const std::string&`**：如果你想取一个字符串的子串（比如前 5 个字符），调用 `s.substr(0, 5)` 会**创建一个全新的 `std::string` 对象**，涉及内存拷贝。
- **`std::string_view`**：调用 `sv.substr(0, 5)` **仅仅是改变了指针的位置和长度数值**。它不会拷贝任何字符，时间复杂度是真正的 **O(1)**

- [ ] 26_1_30



3. [c++]

迭代器有几种分别是什么

- 五种标准迭代器（按功能从弱到强）

#### ① 输入迭代器 (Input Iterator)

- **功能**：只读，只能单向移动（只能 `++`）。
- **特点**：只能读取一次，不支持回退。
- **例子**：`std::istream_iterator`（从输入流读数据）。

#### ② 输出迭代器 (Output Iterator)

- **功能**：只写，只能单向移动（只能 `++`）。
- **特点**：只能写入一次，不能读取。
- **例子**：`std::ostream_iterator`（向输出流写数据）。

#### ③ 前向迭代器 (Forward Iterator)

- **功能**：读写，只能单向移动（只能 `++`）。
- **特点**：可以多次读写同一个位置。
- **例子**：`std::forward_list` (单链表) 的迭代器。

#### ④ 双向迭代器 (Bidirectional Iterator)

- **功能**：读写，可双向移动（支持 `++` 和 `--`）。
- **特点**：可以前后穿梭，但不能像数组那样直接跳到某个位置。
- **例子**：`std::list` (双向链表)、`std::map`、`std::set`。

#### ⑤ 随机访问迭代器 (Random Access Iterator) —— **性能最强**

- **功能**：支持所有操作，包括 `++`, `--`, `+n`, `-n`, 以及 `[]` 下标访问。
- **特点**：可以在 O(1)*O*(1) 时间内跳到任意位置。
- **例子**：`std::vector`、`std::deque`、`std::array`



为什么要知道这些种类

- **`std::sort`**：要求必须是 **随机访问迭代器**。
  - 这就是为什么 `std::vector` 可以直接调用 `std::sort(v.begin(), v.end())`
  - 而 `std::list` 是双向迭代器，不能用 `std::sort`，它必须调用自己的成员函数 `list.sort()`

- **`std::find`**：要求较低，只要是 **输入迭代器** 即可。所以所有的容器都能用 `std::find`

- [ ] 26_1_30





4. [C++]

new 和 malloc 有什么区别

- **`new` / `delete`**：是 C++ 的**运算符**（Keywords/Operators）。编译器可以识别它们，并根据类型自动计算空间。
- **`malloc` / `free`**：是 C/C++ 标准库中的**函数**（Functions）。定义在 `<cstdlib>` (C中为 `<stdlib.h>`) 中



**`new`**：不需要手动指定字节数，只需要跟上**类型名**。它返回的是**具体类型的指针**，不需要强制类型转换。

**`malloc`**：必须手动计算需要分配的**字节数**。它返回的是 `void*` 指针，必须进行**强制类型转换**才能使用。



- **`new`**：不仅分配内存，还会**自动调用构造函数**来初始化对象。对应的 `delete` 会调用析构函数。
- **`malloc`**：**只负责分配内存**，不会调用构造函数。内存中的值是随机的（垃圾值）。对应的 `free` 也不会调用析构函数。
  - *结论：在 C++ 中处理类（Class）对象时，必须使用 `new`*



- **`new`**：如果内存分配失败，默认会**抛出异常** (`std::bad_alloc`)。如果不希望抛出异常，可以使用 `new(std::nothrow)`。
- **`malloc`**：如果分配失败，返回 **`NULL`**。因此使用后必须进行判空检查



| 特性          | `new` / `delete`         | `malloc` / `free`          |
| :------------ | :----------------------- | :------------------------- |
| **来源**      | C++ 运算符               | 标准库函数                 |
| **返回类型**  | 具体类型指针（无需强转） | `void*`（需强转）          |
| **参数**      | 类型名（如 `int`）       | 字节数（如 `sizeof(int)`） |
| **构造/析构** | **自动调用**             | **不调用**                 |
| **失败处理**  | 抛出异常                 | 返回 `NULL`                |
| **安全性**    | 类型安全                 | 类型不安全                 |
| **重载**      | 支持                     | 不支持                     |





5. [C++]

虚表何时初始化

#### A. 虚表（vtable）本身：编译期

- **生成时间**：编译器在**编译阶段**为每个拥有虚函数的类生成虚表。
- **内容**：虚表中存放的是类中所有虚函数的地址。如果派生类重写了基类的虚函数，虚表中对应的条目会被替换为派生类函数的地址。
- **数量**：每个具有虚函数的类都有一个唯一的虚表，该类的所有对象共用这一张表。

#### B. 虚表指针（vptr）的赋值：运行期（构造阶段）

- **赋值时间**：在程序运行时，当对象被创建时，虚表指针 `vptr` 会在**构造函数执行过程中**被初始化。
- **过程**：
  1. 当基类构造函数执行时，`vptr` 指向基类的虚表。
  2. 当派生类构造函数执行时，`vptr` 被改写，指向派生类的虚表





6. [c++]

在图像算法的高频调用中，为什么优先使用 inline？



- **没有跳转，没有压栈**，执行速度极快
  - 普通函数的坏处 ： 
  - **压栈**：将参数、返回地址、寄存器状态压入栈中。
  - **跳转**：CPU 跳到函数的内存地址执行指令。
  - **退栈**：执行完后弹出数据，恢复现场。
  - **跳转回来**：跳回原调用处

- **类型检查**：`inline` 是真正的函数，有严格的参数类型检查 比宏更安全
- 





1. 

```tex
PS E:\Project\LosChess\client-qt\build> cmake --build . --config Release
CMake is re-running because E:/Project/LosChess/client-qt/build/CMakeFiles/generate.stamp is out-of-date.
  the file 'E:/Project/LosChess/client-qt/CMakeLists.txt'
  is newer than 'E:/Project/LosChess/client-qt/build/CMakeFiles/generate.stamp.depend'
  result='-1'
-- Selecting Windows SDK version 10.0.26100.0 to target Windows 10.0.22631.
-- Could NOT find WrapVulkanHeaders (missing: Vulkan_INCLUDE_DIR)
-- Configuring done (0.2s)
-- Generating done (0.2s)
-- Build files have been written to: E:/Project/LosChess/client-qt/build
适用于 .NET Framework MSBuild 版本 18.0.5+e22287bf1

  Automatic MOC for target ClientQt
  LoginRequest.cpp
  auth_request.pb.cc
E:\Project\LosChess\client-qt\src\model\auth_request.pb.h(14,10): error C1083: 无法打开包括文件: “google/protobuf/runtime_versi
on.h”: No such file or directory [E:\Project\LosChess\client-qt\build\ClientQt.vcxproj]
  (compiling source file '../src/net/LoginRequest.cpp')

E:\Project\LosChess\client-qt\src\model\auth_request.pb.h(14,10): error C1083: 无法打开包括文件: “google/protobuf/runtime_versi
on.h”: No such file or directory [E:\Project\LosChess\client-qt\build\ClientQt.vcxproj]
  (compiling source file '../src/model/auth_request.pb.cc')

  auth_response.pb.cc
E:\Project\LosChess\client-qt\src\model\auth_response.pb.h(14,10): error C1083: 无法打开包括文件: “google/protobuf/runtime_vers
ion.h”: No such file or directory [E:\Project\LosChess\client-qt\build\ClientQt.vcxproj]
  (compiling source file '../src/model/auth_response.pb.cc')

  正在生成代码...
PS E:\Project\LosChess\client-qt\build>

cmake_minimum_required(VERSION 3.24)
project(ClientQt LANGUAGES CXX)

set(CMAKE_PREFIX_PATH "E:/Qt/6.10.2/msvc2022_64")
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Qt6 REQUIRED COMPONENTS Core Widgets Network)
qt_standard_project_setup()

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC OFF) 

set(SOURCES
    src/main.cpp
    src/mainwindow.cpp
    src/mainwindow.h
    src/style.h 

    src/ui/LoginDialog/LoginDialog.h
    src/ui/LoginDialog/LoginDialog.cpp
    src/ui/LoginDialog/LoginDialog_style.h

    src/net/BaseRequest.h
    src/net/LoginRequest.h
    src/net/LoginRequest.cpp

    src/model/auth_request.pb.cc
    src/model/auth_request.pb.h
    src/model/auth_response.pb.cc
    src/model/auth_response.pb.h
)

set(FORMS
    src/mainwindow.ui
    src/ui/LoginDialog/LoginDialog.ui
)

qt_wrap_ui(UI_HEADERS ${FORMS})

qt_add_executable(ClientQt WIN32
    MANUAL_FINALIZATION
    ${SOURCES}
    ${UI_HEADERS}
)

if(MSVC)
    target_compile_options(ClientQt PRIVATE
        /utf-8               
        /W4                  
        /wd4828              
    )
    target_link_options(ClientQt PRIVATE /SUBSYSTEM:WINDOWS)
endif()

target_link_libraries(ClientQt 
    PRIVATE 
    Qt6::Widgets
    Qt6::Core 
    Qt6::Network
)

target_include_directories(ClientQt PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/src
    ${CMAKE_CURRENT_SOURCE_DIR}/src/ui
    ${CMAKE_CURRENT_SOURCE_DIR}/src/net
    ${CMAKE_CURRENT_SOURCE_DIR}/src/model
    ${CMAKE_CURRENT_SOURCE_DIR}/build
    ${CMAKE_CURRENT_BINARY_DIR}
)

qt_finalize_executable(ClientQt)


怎么办？
```

- find_package(Protobuf REQUIRED)

- ```cmake
  target_link_libraries(ClientQt 
      PRIVATE 
      Qt6::Widgets
      Qt6::Core 
      Qt6::Network
      protobuf::libprotobuf 
  )
  ```

- ```cmake
  target_include_directories(ClientQt PRIVATE
      ${CMAKE_CURRENT_SOURCE_DIR}/src
      ${CMAKE_CURRENT_SOURCE_DIR}/src/ui
      ${CMAKE_CURRENT_SOURCE_DIR}/src/net
      ${CMAKE_CURRENT_SOURCE_DIR}/src/model
      ${CMAKE_CURRENT_SOURCE_DIR}/build
      ${CMAKE_CURRENT_BINARY_DIR}
  
      ${Protobuf_INCLUDE_DIRS} 
  )
  ```

- ```cmake
  set(Protobuf_DIR "E:/protobuf/protobuf-33.5/install/lib/cmake/protobuf")
  ```

  - 这个路径设置的关键在于：**这个目录下必须包含 `protobuf-config.cmake` 这个文件**





2. 

- **Protobuf 的库 (`libprotobuf.lib`)**：是用 `/MT` (Static Runtime) 编译的。意思是它把 C++ 的运行库直接打进了包里。
- **你的项目 (`ClientQt`)**：是用 `/MD` (Dynamic Runtime) 编译的。这是 Qt 的默认方式，也是现代 Windows 开发的标准。
- **冲突**：MSVC 禁止在一个程序里同时混用 `/MT` 和 `/MD`



3. 

```shell
cmake -A x64 -Dprotobuf_MSVC_STATIC_RUNTIME=OFF -DCMAKE_INSTALL_PREFIX="E:/protobuf/install" -Dprotobuf_BUILD_TESTS=OFF ..
详细介绍这个指令
```

- -A x64 指定生成 **64位 (x64)** 的工程

- ### `-Dprotobuf_MSVC_STATIC_RUNTIME=OFF`

  - **ON (默认值)**：编译器使用 `/MT` 选项
  - **OFF**：编译器使用 **`/MD`** 选项

- ### `-DCMAKE_INSTALL_PREFIX="E:/protobuf/install"`

  - 默认安装路径

- ### `-Dprotobuf_BUILD_TESTS=OFF`

  - 不编译 Protobuf 自带的测试用例



4. 

```cmake
cmake --install . --config Release
这一步的本质是什么

我知道
cmake --build . --config Release
这个可以生成 exe文件

那么上面那个指令
是根据程序员在哪个文件的设置
才会生成 bin lib include这样的目录群？
```



- **`--build` 是生产零件，而 `--install` 是成品出库并打包成 SDK**

  - 它是增量开发的灵魂

  - 它是为了“调试”

  - 会调用真正的编译器



5. [cmake]

如何决定 bin include lib?
这些东西假如我自己要写包 要怎么写
详细语法介绍一下

```tex
MyMathProject/
├── CMakeLists.txt
├── include/
│   └── MyMath.h
└── src/
    └── MyMath.cpp

```



```cmake
cmake_minimum_required(VERSION 3.10)
project(MyMath VERSION 1.0)

# 1. 定义你的库
add_library(MyMath STATIC src/MyMath.cpp)

# 2. 设置头文件路径（编译时用）
target_include_directories(MyMath PUBLIC 
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include> # 这一行很重要，告诉 CMake 安装后去哪找头文件
)

# 3. --- 开始编写安装规则 ---

# 安装 .lib 文件到 lib 目录
install(TARGETS MyMath
        ARCHIVE DESTINATION lib
        LIBRARY DESTINATION lib
        RUNTIME DESTINATION bin)

# 安装头文件到 include 目录
install(DIRECTORY include/ 
        DESTINATION include)

# 4. (进阶) 生成让别人能 find_package 的文件
# 就像 Protobuf 一样，这一步能生成 MyMathConfig.cmake
install(EXPORT MyMathTargets
        FILE MyMathTargets.cmake
        DESTINATION lib/cmake/MyMath)

```
