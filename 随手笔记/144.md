1. 

```tex
PS E:\Project\LosChess\client-qt\build> cmake --build . --config Release
CMake is re-running because E:/Project/LosChess/client-qt/build/CMakeFiles/generate.stamp is out-of-date.
  the file 'E:/Project/LosChess/client-qt/CMakeLists.txt'
  is newer than 'E:/Project/LosChess/client-qt/build/CMakeFiles/generate.stamp.depend'
  result='-1'
-- Selecting Windows SDK version 10.0.26100.0 to target Windows 10.0.22631.
-- Could NOT find WrapVulkanHeaders (missing: Vulkan_INCLUDE_DIR)
-- Configuring done (0.2s)
-- Generating done (0.2s)
-- Build files have been written to: E:/Project/LosChess/client-qt/build
适用于 .NET Framework MSBuild 版本 18.0.5+e22287bf1

  Automatic MOC for target ClientQt
  LoginRequest.cpp
  auth_request.pb.cc
E:\Project\LosChess\client-qt\src\model\auth_request.pb.h(14,10): error C1083: 无法打开包括文件: “google/protobuf/runtime_versi
on.h”: No such file or directory [E:\Project\LosChess\client-qt\build\ClientQt.vcxproj]
  (compiling source file '../src/net/LoginRequest.cpp')

E:\Project\LosChess\client-qt\src\model\auth_request.pb.h(14,10): error C1083: 无法打开包括文件: “google/protobuf/runtime_versi
on.h”: No such file or directory [E:\Project\LosChess\client-qt\build\ClientQt.vcxproj]
  (compiling source file '../src/model/auth_request.pb.cc')

  auth_response.pb.cc
E:\Project\LosChess\client-qt\src\model\auth_response.pb.h(14,10): error C1083: 无法打开包括文件: “google/protobuf/runtime_vers
ion.h”: No such file or directory [E:\Project\LosChess\client-qt\build\ClientQt.vcxproj]
  (compiling source file '../src/model/auth_response.pb.cc')

  正在生成代码...
PS E:\Project\LosChess\client-qt\build>

cmake_minimum_required(VERSION 3.24)
project(ClientQt LANGUAGES CXX)

set(CMAKE_PREFIX_PATH "E:/Qt/6.10.2/msvc2022_64")
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Qt6 REQUIRED COMPONENTS Core Widgets Network)
qt_standard_project_setup()

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC OFF) 

set(SOURCES
    src/main.cpp
    src/mainwindow.cpp
    src/mainwindow.h
    src/style.h 

    src/ui/LoginDialog/LoginDialog.h
    src/ui/LoginDialog/LoginDialog.cpp
    src/ui/LoginDialog/LoginDialog_style.h

    src/net/BaseRequest.h
    src/net/LoginRequest.h
    src/net/LoginRequest.cpp

    src/model/auth_request.pb.cc
    src/model/auth_request.pb.h
    src/model/auth_response.pb.cc
    src/model/auth_response.pb.h
)

set(FORMS
    src/mainwindow.ui
    src/ui/LoginDialog/LoginDialog.ui
)

qt_wrap_ui(UI_HEADERS ${FORMS})

qt_add_executable(ClientQt WIN32
    MANUAL_FINALIZATION
    ${SOURCES}
    ${UI_HEADERS}
)

if(MSVC)
    target_compile_options(ClientQt PRIVATE
        /utf-8               
        /W4                  
        /wd4828              
    )
    target_link_options(ClientQt PRIVATE /SUBSYSTEM:WINDOWS)
endif()

target_link_libraries(ClientQt 
    PRIVATE 
    Qt6::Widgets
    Qt6::Core 
    Qt6::Network
)

target_include_directories(ClientQt PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/src
    ${CMAKE_CURRENT_SOURCE_DIR}/src/ui
    ${CMAKE_CURRENT_SOURCE_DIR}/src/net
    ${CMAKE_CURRENT_SOURCE_DIR}/src/model
    ${CMAKE_CURRENT_SOURCE_DIR}/build
    ${CMAKE_CURRENT_BINARY_DIR}
)

qt_finalize_executable(ClientQt)


怎么办？
```

- find_package(Protobuf REQUIRED)

- ```cmake
  target_link_libraries(ClientQt 
      PRIVATE 
      Qt6::Widgets
      Qt6::Core 
      Qt6::Network
      protobuf::libprotobuf 
  )
  ```

- ```cmake
  target_include_directories(ClientQt PRIVATE
      ${CMAKE_CURRENT_SOURCE_DIR}/src
      ${CMAKE_CURRENT_SOURCE_DIR}/src/ui
      ${CMAKE_CURRENT_SOURCE_DIR}/src/net
      ${CMAKE_CURRENT_SOURCE_DIR}/src/model
      ${CMAKE_CURRENT_SOURCE_DIR}/build
      ${CMAKE_CURRENT_BINARY_DIR}
  
      ${Protobuf_INCLUDE_DIRS} 
  )
  ```

- ```cmake
  set(Protobuf_DIR "E:/protobuf/protobuf-33.5/install/lib/cmake/protobuf")
  ```

  - 这个路径设置的关键在于：**这个目录下必须包含 `protobuf-config.cmake` 这个文件**





2. 

- **Protobuf 的库 (`libprotobuf.lib`)**：是用 `/MT` (Static Runtime) 编译的。意思是它把 C++ 的运行库直接打进了包里。
- **你的项目 (`ClientQt`)**：是用 `/MD` (Dynamic Runtime) 编译的。这是 Qt 的默认方式，也是现代 Windows 开发的标准。
- **冲突**：MSVC 禁止在一个程序里同时混用 `/MT` 和 `/MD`



3. 

```shell
cmake -A x64 -Dprotobuf_MSVC_STATIC_RUNTIME=OFF -DCMAKE_INSTALL_PREFIX="E:/protobuf/install" -Dprotobuf_BUILD_TESTS=OFF ..
详细介绍这个指令
```

- -A x64 指定生成 **64位 (x64)** 的工程

- ### `-Dprotobuf_MSVC_STATIC_RUNTIME=OFF`

  - **ON (默认值)**：编译器使用 `/MT` 选项
  - **OFF**：编译器使用 **`/MD`** 选项

- ### `-DCMAKE_INSTALL_PREFIX="E:/protobuf/install"`

  - 默认安装路径

- ### `-Dprotobuf_BUILD_TESTS=OFF`

  - 不编译 Protobuf 自带的测试用例



4. 

```cmake
cmake --install . --config Release
这一步的本质是什么

我知道
cmake --build . --config Release
这个可以生成 exe文件

那么上面那个指令
是根据程序员在哪个文件的设置
才会生成 bin lib include这样的目录群？
```



- **`--build` 是生产零件，而 `--install` 是成品出库并打包成 SDK**

  - 它是增量开发的灵魂

  - 它是为了“调试”

  - 会调用真正的编译器



5. [cmake]

如何决定 bin include lib?
这些东西假如我自己要写包 要怎么写
详细语法介绍一下

```tex
MyMathProject/
├── CMakeLists.txt
├── include/
│   └── MyMath.h
└── src/
    └── MyMath.cpp

```



```cmake
cmake_minimum_required(VERSION 3.10)
project(MyMath VERSION 1.0)

# 1. 定义你的库
add_library(MyMath STATIC src/MyMath.cpp)

# 2. 设置头文件路径（编译时用）
target_include_directories(MyMath PUBLIC 
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include> # 这一行很重要，告诉 CMake 安装后去哪找头文件
)

# 3. --- 开始编写安装规则 ---

# 安装 .lib 文件到 lib 目录
install(TARGETS MyMath
        ARCHIVE DESTINATION lib
        LIBRARY DESTINATION lib
        RUNTIME DESTINATION bin)

# 安装头文件到 include 目录
install(DIRECTORY include/ 
        DESTINATION include)

# 4. (进阶) 生成让别人能 find_package 的文件
# 就像 Protobuf 一样，这一步能生成 MyMathConfig.cmake
install(EXPORT MyMathTargets
        FILE MyMathTargets.cmake
        DESTINATION lib/cmake/MyMath)

```

