1. 工厂模式

```c++
#include <iostream>
#include <string_view>

class project {

public:
  virtual void show() = 0;
  virtual ~project() = default;
};

class projectA : public project {

public:
  void show() override { std::cout << 'a' << std::endl; }
};

class projectB : public project {
public:
  void show() override { std::cout << 'b' << std::endl; };
};

class Fac {
public:
  static project *getProject(std::string_view type) {
    if (type == "a") {
      return new projectA();
    } else if (type == "b") {
      return new projectB();
    }
    return nullptr;
  }
};

int main() {

  project *pro = Fac::getProject("a");
  pro->show();
  return 0;
}
```

1. **虚析构函数**我在基类中定义了虚析构函数，这是为了防止在多态环境下，通过基类指针删除派生类对象时发生内存泄漏。”
2. **纯虚函数**：“我将 `show()` 定义为纯虚函数，这样 `project` 就变成了抽象基类，防止被误实例化，同时也强制子类必须实现该接口。”
3. **智能指针**：“在工厂模式中，我推荐返回 `std::unique_ptr`。因为工厂模式将创建对象的权利交给了外部，使用智能指针可以明确**所有权转移**，并避免手动 `delete` 遗漏导致的内存泄漏。”
4. **string_view**：“我使用了 C++17 的 `string_view` 作为参数，它避免了不必要的字符串拷贝，提升了传递效率。

- [ ] 26_1_30





2. [c++]

string_view 和 传入 const string& 的区别？



- **`const std::string&`**：如果你传入一个字符串字面量（比如 `"hello"`），编译器必须先构造一个**临时的 `std::string` 对象**，这可能会触发堆内存分配（Heap Allocation）。
- **`std::string_view`**：它只是一个**“视图”**（内部就是一个 `char*` 指针 + 一个 `size_t` 长度）。当你传入 `"hello"` 时，它直接指向这块常量区，**没有任何内存分配开销**

- [x] 26_1_30



- 子串处理方面

- **`const std::string&`**：如果你想取一个字符串的子串（比如前 5 个字符），调用 `s.substr(0, 5)` 会**创建一个全新的 `std::string` 对象**，涉及内存拷贝。
- **`std::string_view`**：调用 `sv.substr(0, 5)` **仅仅是改变了指针的位置和长度数值**。它不会拷贝任何字符，时间复杂度是真正的 **O(1)**

- [ ] 26_1_30



3. [c++]

迭代器有几种分别是什么

- 五种标准迭代器（按功能从弱到强）

#### ① 输入迭代器 (Input Iterator)

- **功能**：只读，只能单向移动（只能 `++`）。
- **特点**：只能读取一次，不支持回退。
- **例子**：`std::istream_iterator`（从输入流读数据）。

#### ② 输出迭代器 (Output Iterator)

- **功能**：只写，只能单向移动（只能 `++`）。
- **特点**：只能写入一次，不能读取。
- **例子**：`std::ostream_iterator`（向输出流写数据）。

#### ③ 前向迭代器 (Forward Iterator)

- **功能**：读写，只能单向移动（只能 `++`）。
- **特点**：可以多次读写同一个位置。
- **例子**：`std::forward_list` (单链表) 的迭代器。

#### ④ 双向迭代器 (Bidirectional Iterator)

- **功能**：读写，可双向移动（支持 `++` 和 `--`）。
- **特点**：可以前后穿梭，但不能像数组那样直接跳到某个位置。
- **例子**：`std::list` (双向链表)、`std::map`、`std::set`。

#### ⑤ 随机访问迭代器 (Random Access Iterator) —— **性能最强**

- **功能**：支持所有操作，包括 `++`, `--`, `+n`, `-n`, 以及 `[]` 下标访问。
- **特点**：可以在 O(1)*O*(1) 时间内跳到任意位置。
- **例子**：`std::vector`、`std::deque`、`std::array`



为什么要知道这些种类

- **`std::sort`**：要求必须是 **随机访问迭代器**。
  - 这就是为什么 `std::vector` 可以直接调用 `std::sort(v.begin(), v.end())`
  - 而 `std::list` 是双向迭代器，不能用 `std::sort`，它必须调用自己的成员函数 `list.sort()`

- **`std::find`**：要求较低，只要是 **输入迭代器** 即可。所以所有的容器都能用 `std::find`

- [ ] 26_1_30





4. [C++]

new 和 malloc 有什么区别

- **`new` / `delete`**：是 C++ 的**运算符**（Keywords/Operators）。编译器可以识别它们，并根据类型自动计算空间。
- **`malloc` / `free`**：是 C/C++ 标准库中的**函数**（Functions）。定义在 `<cstdlib>` (C中为 `<stdlib.h>`) 中



**`new`**：不需要手动指定字节数，只需要跟上**类型名**。它返回的是**具体类型的指针**，不需要强制类型转换。

**`malloc`**：必须手动计算需要分配的**字节数**。它返回的是 `void*` 指针，必须进行**强制类型转换**才能使用。



- **`new`**：不仅分配内存，还会**自动调用构造函数**来初始化对象。对应的 `delete` 会调用析构函数。
- **`malloc`**：**只负责分配内存**，不会调用构造函数。内存中的值是随机的（垃圾值）。对应的 `free` 也不会调用析构函数。
  - *结论：在 C++ 中处理类（Class）对象时，必须使用 `new`*



- **`new`**：如果内存分配失败，默认会**抛出异常** (`std::bad_alloc`)。如果不希望抛出异常，可以使用 `new(std::nothrow)`。
- **`malloc`**：如果分配失败，返回 **`NULL`**。因此使用后必须进行判空检查



| 特性          | `new` / `delete`         | `malloc` / `free`          |
| :------------ | :----------------------- | :------------------------- |
| **来源**      | C++ 运算符               | 标准库函数                 |
| **返回类型**  | 具体类型指针（无需强转） | `void*`（需强转）          |
| **参数**      | 类型名（如 `int`）       | 字节数（如 `sizeof(int)`） |
| **构造/析构** | **自动调用**             | **不调用**                 |
| **失败处理**  | 抛出异常                 | 返回 `NULL`                |
| **安全性**    | 类型安全                 | 类型不安全                 |
| **重载**      | 支持                     | 不支持                     |





5. [C++]

虚表何时初始化

#### A. 虚表（vtable）本身：编译期

- **生成时间**：编译器在**编译阶段**为每个拥有虚函数的类生成虚表。
- **内容**：虚表中存放的是类中所有虚函数的地址。如果派生类重写了基类的虚函数，虚表中对应的条目会被替换为派生类函数的地址。
- **数量**：每个具有虚函数的类都有一个唯一的虚表，该类的所有对象共用这一张表。

#### B. 虚表指针（vptr）的赋值：运行期（构造阶段）

- **赋值时间**：在程序运行时，当对象被创建时，虚表指针 `vptr` 会在**构造函数执行过程中**被初始化。
- **过程**：
  1. 当基类构造函数执行时，`vptr` 指向基类的虚表。
  2. 当派生类构造函数执行时，`vptr` 被改写，指向派生类的虚表





6. [c++]

在图像算法的高频调用中，为什么优先使用 inline？



- **没有跳转，没有压栈**，执行速度极快
  - 普通函数的坏处 ： 
  - **压栈**：将参数、返回地址、寄存器状态压入栈中。
  - **跳转**：CPU 跳到函数的内存地址执行指令。
  - **退栈**：执行完后弹出数据，恢复现场。
  - **跳转回来**：跳回原调用处

- **类型检查**：`inline` 是真正的函数，有严格的参数类型检查 比宏更安全
- 









