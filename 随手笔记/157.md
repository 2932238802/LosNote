1. [c++]

```tex
如何理解 
INVALID_SOCKET
SOCK_STREAM
AF_INET
IPPROTO_TCP
这些宏
以及 socket 函数
windows.h?
```

- #### **AF_INET** 

  - 协议族 IPv4

- SOCKET_STREAM

  - 指定这个套接字 具有 流式传输特征

- IPPROTO_TCP

  - 指定传输层 用 tcp

- INVALID_SOCKET



2. [c++]

```tx
如何理解 
    int opt = 1;
    setsockopt(LOS_serverFd, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt));

这两行?
```

- tcp的技术背景
  - 当一个 Tcp 连接由服务器主动关闭，该连接在内核中并不会立即销毁，而是进入一个2 MSL 的 TIME_WAIT 状态
  - 这个状态下 内核会死锁这个 窗口
  - 如果 你重新 启动服务器程序 尝试对同一个端口调用 bind() 内核会检查Tcb表，发现该端口任限于受限状态，从而返回 EADDRINUSE 错误
- SOL_SOCKET
  - 表示 通用套接字层
- SO_REUSEADDR
  - 它 允许内核重用现有的端口条目，而不必等待 2MSL 定时器耗尽



3. [c++]

```tex
if (bind(LOS_serverFd, (struct sockaddr*)(&addr), sizeof(addr)) == SOCKET_ERROR) {
    LOGE("Bind failed with error: " + std::to_string(WSAGetLastError()));
    return false;
}

if (listen(LOS_serverFd, 5) == SOCKET_ERROR) {
    return false;
}

如何理解 bind listen 还有为啥 错误都是 SOCKET_ERROR?
```

- 调用 socket的时候 内核会分配资源
- 但是这个 套接字 在网络栈中是 匿名的 。 它没有关联到任何具体的网络接口和端口
- bind 系统调用 会将用户态 定义的sockaddr_in 结构体中的数据 拷贝到内核中 该套接字对应的 TCB
- bind 返回错误的原因是 ：
  - bind 系统调用 会让内核便利当前的已占用的地址表 。 如果发现 该[ip:port] 组合已经被其它进程的TCB 占用 ， 内核会拒绝此操作，返回错误
- Socket 缓冲区 不在 TCB ， 但是TCB 控制块持有指向这些缓冲区的指针
- 缓冲区 ： 是内核在内存中开辟的动态空间，用于存放真实的字节流
  - 发送缓冲区: 存放应用层调用send发送过来，但协议栈还没发出来
  - 接受缓冲区: 存放网卡接受并拼装好，但应用层还没调用recv取走的数据

- 开机的时候 内核 会自动在自己的内存空间初始化网络协议栈，这个包括预留用于管理连接的TCB 内存池，和管理数据传输的缓冲区管理系统
- 当运行的时候 操作系统会通过内核创建一个进程对象
- 内核为该进程分配独立的虚拟地址空间(Ring 3) , 并创建一个句柄表，这个表是该进程访问内核资源的唯一索引
- 内核将程序的代码段和数据段从磁盘加载到虚拟内存，CPU开始main

- 进程的句柄表 
  - 文件句柄
  - 线程和进程的句柄
  - 同步对象
  - 管道和邮件的槽
- 进程调用 socket()的时候，进程会创建一个Socket内核对象，在i就能成的句柄表中填入一个条目，返回一个索引
- 用户态的fd只是一个代号，只有配合“当前进程的上下文”，它才有意义
- 内存区域
  - 低地址区域 main.cpp 定义的变量 std::vector数据等
  - 高地址区域 内核代码 TCB Socket对象
- 是否为分页池内存
  - 如果是普通内存 如果内存不够了 操作系统可以把你的代码，暂时半岛硬盘的虚拟内存的文件里面
  - 如果 不是 永远不允许搬到硬盘
    - 网络卡驱动在收包的时候 是 异步的 ，它必须随时能找到内存里面的TCB 缓冲区 ，如果此时这块内存被操作系统搬到了硬盘，网卡驱动就崩溃了
- Win32 API 设计的规范约定，返回值只代表信号，具体的错误码存储在别处



4. [c++]

- WSAGetLastError
  - 获取 最近一次 winsock 系统调用产生的错误码





5. [c++] Qt

```c++
QTimer的各个信号的意义？
```

- timeout 信号 就是 start 结束之后发送的

- QTimer::singleShot 就是执行一次的函数

  - ```c++
    QTimer::singleShot(5000, this, &MyClass::onTimeOut);
    ```















