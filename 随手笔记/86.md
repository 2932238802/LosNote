1. QPropertyAnimation(QObject *target, const QByteArray &propertyName, QObject *parent = nullptr)

三个参数 分别是 要动画化的目标对象 第二个参数是 要动画化的属性名称 第三个参数是父对象的指针

- [x] 12_29



2. 

constexpr 在编译的时候就被求值



和 宏的区别？



宏没有类型检查

和constexpr比不了 后者太安全了



3.  [rust]

`cargo build` 命令需要在包含 `Cargo.toml` 文件的**项目根目录**下执行



4. 

 获取vec通过get的方法

```rust
fn main(){
    let mut v = vec![1,2,3];
    v.push(1);
    
    match  v.get(3) {
        Some(index) =>{
            print!("{}",index);
        }
        None =>{
            print!("超过范围");
        }
    }

}
```





5. 



```rust
fn main(){
    let mut v = vec![1,2,3];
    v.push(1);

    let value_1 = v[2];  // 只读复印件
    let mut value_2 = v[2];  // 可修改复印件
    let  value_3 = mut v[2]; // 错误
    let mut value_4 = mut v[2]; // 错误
    let value_5 = &mut v[2]; // 一个不可变的变量 存着一个可变的引用 就是地址不变 但是地址的值可变
    let mut value_6 = &mut v[2]; // 能改数据的同时 也能改 地址的值
    let value_7 = &v[2]; // 
    let mut value_8 = &v[2];
}
```

​          

| 变量      | 类型       | 原数组 v | 修改变量的值?      | 重新指向别人?   | 备注                                               |
| :-------- | :--------- | :------- | :----------------- | :-------------- | :------------------------------------------------- |
| `value_1` | `i32`      | 没关系   | ❌ 不可             | ❌ 不可          | 只是个复印件                                       |
| `value_2` | `i32`      | 没关系   | ✅ **可** (不影响v) | ✅ **可** (赋值) | 只是个可涂写的复印件                               |
| `value_5` | `&mut i32` | **引用** | ✅ **可** (影响v)   | ❌ 不可          | **最常用的修改数组方式**                           |
| `value_6` | `&mut i32` | **引用** | ✅ **可** (影响v)   | ✅ **可**        | 只有当且仅当你想复用这个指针变量时才用             |
| `value_7` | `&i32`     | **引用** | ❌ 不可             | ❌ 不可          | **最常用的只读方式**                               |
| `value_8` | `&i32`     | **引用** | ❌ 不可             | ✅ **可**        | 像个移动的监控探头，只能看不能动，但探头位置可以移 |

















