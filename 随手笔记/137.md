1. [C++] 旋转操作

/////////////////////////////////////////////////////////////////////////////

记住 口诀 
左(左旋)   左(左边变孩子)  左(右边的左孩子)  右(作为左边的右孩子)

右(右旋)   右(右边变孩子)  右(左边的右孩子)  左(作为右边的左孩子) 

- [x] 26_1_28



2. 

如何 判断一个树是不是平衡树

```c++
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return getHeight(root) != -1;
    }

private:
    int getHeight(TreeNode* node) {
        if (node == nullptr) return 0;

        // 递归检查左子树
        int leftH = getHeight(node->left);
        if (leftH == -1) return -1; // 提前剪枝

        // 递归检查右子树
        int rightH = getHeight(node->right);
        if (rightH == -1) return -1; // 提前剪枝

        // 如果高度差超过1，返回-1表示不平衡
        if (abs(leftH - rightH) > 1) return -1;

        // 否则返回当前节点的真实高度
        return max(leftH, rightH) + 1;
    }
};
```

- [ ] 26_1_28







3. 

Vector容量上限是多少？

Vector扩容策略？？



- 逻辑上限和物理上限
  - 在 64 位系统下，这个值非常大（接近 264264），但在 32 位系统下，受到 4GB 地址空间的限制，它通常在几亿个元素左右
  - 由于 `vector` 要求内存必须是**连续的**，所以即使你有 8GB 空闲内存，但如果没有一整块连续的 4GB 空间，你依然无法申请一个 4GB 大小的 `vector`

- [ ] 26_1_28



4. 

- 当 `vector.size() == vector.capacity()` 时，如果你再往里 `push_back` 一个元素，就会触发**自动扩容**
- ![image-20260128150710505](D:\LosAngelous\LosNote\随手笔记\png\image-20260128150710505.png)

- [x] 26_1_28





5. 

Lambda表达式用过嘛？它是如何捕获外部变量的？这些捕获的外部变量存储在哪里？

- **值捕获 `[var]`**：编译器会将该变量作为该匿名类的**成员变量**，并在构造这个类时，通过**拷贝构造函数**将外部变量的值存入其中。
- **引用捕获 `[&var]`**：编译器会将该变量的**引用或指针**作为匿名类的成员变量。
- **隐式捕获 `[=]` 或 `[&]`**：编译器会根据 Lambda 体内实际用到了哪些变量，自动决定把哪些变量“塞进”类成员里

- [ ] 26_1_28



**捕获的变量存储在 Lambda 产生的“闭包对象”（Closure Object）内部**



6. 

引用捕获的生命周期陷阱：
如果 Lambda 是异步执行的（比如传给另一个线程）或者作为返回值返回，而你使用了引用捕获，那么当原变量作用域结束被销毁时，Lambda 内部的引用就会变成悬空引用（Dangling Reference），导致崩溃。

- 金律：生命周期短的 Lambda 用引用捕获；生命周期长的（异步、返回给外部）务必用值捕获

- [x] 26_1_28



关于这一点
如何理解
lambda是作为返回值返回？

- ```c++
  #include <iostream>
  #include <functional>
  
  std::function<int()> makeLambda() {
      int local_val = 100; // 这是一个局部变量，分配在栈上
      
      // 错误点：使用 [&] 引用捕获了 local_val
      auto myLambda = [&local_val]() {
          return local_val + 10;
      };
  
      return myLambda; // Lambda 对象被传出去了，但 local_val 留在函数里
  } // <--- 执行到这里，local_val 生命周期结束，被销毁
  
  int main() {
      auto func = makeLambda(); 
      
      // 此时调用 func()，它尝试去访问 local_val
      // 但 local_val 原来的内存地址现在可能已经是垃圾数据，或者被其他函数占用了
      std::cout << func() << std::endl; // 崩溃或输出乱码（Undefined Behavior）
      return 0;
  }
  ```











