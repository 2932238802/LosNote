1. to_chars
   比to_string 的优势在哪？

| 特性维度               | `std::to_string` (家用轿车) | `std::to_chars` (F1赛车)   | 优势解读                                                     |
| :--------------------- | :-------------------------- | :------------------------- | :----------------------------------------------------------- |
| **1. 性能**            | 中等                        | **极致，通常快一个数量级** | `to_chars` 是目前C++标准库中最快的数字转字符串方式，没有之一。 |
| **2. 内存分配**        | **总是在堆上分配** (`new`)  | **从不分配内存**           | 这是性能差异的**根源**。`to_string` 返回一个 `std::string`，必须在堆上申请内存。而 `to_chars` 在你提供的栈上或已存在的缓冲区中工作。 |
| **3. 异常处理**        | 可能抛出 `std::bad_alloc`   | **从不抛出异常**           | `to_chars` 使用错误码 `std::errc` 返回，是 `noexcept` 的。这使其在不能使用异常的环境（如嵌入式、游戏引擎核心）中成为唯一选择。 |
| **4. 本地化 (Locale)** | 结果可能受本地化影响        | **结果完全独立于本地化**   | `to_chars` 保证 `3.14` 在任何系统上都转换成 `"3.14"`，而不会变成 `"3,14"`。这对于数据交换（如JSON、XML）至关重要。 |
| **5. 控制力与灵活性**  | 功能单一，只能转十进制      | **极高**                   | `to_chars` 可以指定**任意进制**（2-36），并且可以精确控制浮点数的格式（科学计数法、定点等）。 |



- [ ] 11_20



2. :warning:

为什么 需要 内存对齐

如果一个数据 的起始地址 正好是一个字长的整数倍
那么CPU 只需要一次内存访问 就能读取它
但是 它 跨越了 两个字的 边界 
CPU 可能需要 进行两次 内存访问 
然后将 结果拼接起来 
这会显著降低性能 在某些 体系的结构上 访问未对齐的内存甚至会直接导致程序崩溃
对于一些 特殊指令集 它们操作的数据 必须在 16 32 或 64 字节的边界上对齐

3. 

如果不记得 一些变量 你直接 可以使用 通配符就好了

```sql
mysql> show global status like "%size%";
+-------------------------------------------+-----------+
| Variable_name                             | Value     |
+-------------------------------------------+-----------+
| Innodb_buffer_pool_resize_status          |           |
| Innodb_buffer_pool_resize_status_code     | 0         |
| Innodb_buffer_pool_resize_status_progress | 0         |
| Innodb_redo_log_logical_size              | 512       |
| Innodb_redo_log_physical_size             | 3276800   |
| Innodb_redo_log_capacity_resized          | 104857600 |
| Innodb_redo_log_resize_status             | OK        |
| Innodb_page_size                          | 16384     |
| Ssl_session_cache_size                    | 128       |
| Tc_log_page_size                          | 0         |
+-------------------------------------------+-----------+
10 rows in set (0.03 sec)
mysql>

```


- 16384 就是 16 KB  Innodb_page_size 默认大小




4. Innodb_page_size 定义了InnoDb存储引擎上在磁盘上管理数据的最小单元的大小，它就像一本书中的每一页纸的大小，所有的数据和索引都必须被“印刷”在这些大小固定的“页面”上

- [ ] 11_20




5.  Mysql的数据目录

Mysql 服务器的管理信息，业务数据，日志文件，磁盘缓冲文件默认存储在 Mysql数据目录

- 地位
  - Mysql 工作时 主要操作的目录 最重要的目录 没有之一
- 位置
  - /var/lib/mysql
- 各个组成部分
  - 管理信息 （用户名 和 密码  用户的授权等）
  - 业务数据（用户创建的表和库 及其 表中的数据）
  - 日志文件 （慢查询日志 回滚日志 等）
  - 磁盘缓冲文件 （暂时 缓冲的位置）





