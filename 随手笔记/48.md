1. 

   ```c++
   如何理解
   std::exchang？
   ```

```c++
#include <bits/stdc++.h>
#include <utility>

using namespace std;

int main()
{
  int x = 10;

  int old_x = std::exchange(x, 12);

  std::cout << x << std::endl;
  std::cout << old_x << std::endl;

  return 0;
    
}
```

```shell
losangelous@LosAngelous:~/LosAngelous/Project/test$ ./run2
12
10
```

- [ ] 11_17





2. 

```c++
#include <bits/stdc++.h>
#include <utility>

using namespace std;

int main()
{
  std::vector<int> contain{1, 23, 4};

  std::exchange(contain, std::vector<int>{1, 3, 4, 5});

  for (auto a : contain)
  {
    cout << a << " ";
  }
  cout << endl;

  return 0;
}
```
输出 1 3 4 5

- [ ] 11_17
- [ ] 



3. 

-  redis 是在分布式系统使用的

- [ ] 11_16





4. 

- 和mysql 相比 redis 存储空间是有限的
- 虽然速度很快





5. 

工厂模式

- 简单工厂模式

  统一工厂实现

```c++
class SimplePizzaFactory {
public:
    // 核心的静态创建方法
    static std::unique_ptr<Pizza> createPizza(const std::string& type) {
        if (type == "cheese") {
            return std::make_unique<CheesePizza>();
        } else if (type == "pepperoni") {
            return std::make_unique<PepperoniPizza>();
        }
        return nullptr;
    }
};
```



- 工厂方法模式

  把工厂变为虚函数

```c++
class PizzaStore {
public:
    // 这是业务逻辑，它依赖于工厂方法
    std::unique_ptr<Pizza> orderPizza(const std::string& type) {
        std::unique_ptr<Pizza> pizza = createPizza(type); // 调用工厂方法
        pizza->prepare();
        // ... bake, cut, box
        return pizza;
    }
    // 2. 工厂方法 (纯虚函数，由子类实现)
    virtual std::unique_ptr<Pizza> createPizza(const std::string& type) = 0;
    virtual ~PizzaStore() {}
};
```





- 抽象工厂模式

```c++
class Dough { public: virtual std::string getName() = 0; virtual ~Dough() {} };
class Sauce { public: virtual std::string getName() = 0; virtual ~Sauce() {} };

// 具体产品
class ThinCrustDough : public Dough { public: std::string getName() override { return "Thin Crust Dough"; } };
class ThickCrustDough : public Dough { public: std::string getName() override { return "Thick Crust Dough"; } };
class MarinaraSauce : public Sauce { public: std::string getName() override { return "Marinara Sauce"; } };

// 2. 抽象工厂接口
class PizzaIngredientFactory {
public:
    virtual std::unique_ptr<Dough> createDough() = 0;
    virtual std::unique_ptr<Sauce> createSauce() = 0;
    virtual ~PizzaIngredientFactory() {}
};

// 3. 具体工厂，负责创建某个产品族
class NYPizzaIngredientFactory : public PizzaIngredientFactory {
public:
    std::unique_ptr<Dough> createDough() override { return std::make_unique<ThinCrustDough>(); }
    std::unique_ptr<Sauce> createSauce() override { return std::make_unique<MarinaraSauce>(); }
};

class ChicagoPizzaIngredientFactory : public PizzaIngredientFactory {
public:
    std::unique_ptr<Dough> createDough() override { return std::make_unique<ThickCrustDough>(); }
    std::unique_ptr<Sauce> createSauce() override { return std::make_unique<MarinaraSauce>(); } // 假设酱料一样
};

// 使用工厂的客户端 (比如一个更通用的Pizza类)
class GenericPizza {
    std::unique_ptr<Dough> dough;
    std::unique_ptr<Sauce> sauce;
public:
    GenericPizza(std::unique_ptr<PizzaIngredientFactory> factory) {
        dough = factory->createDough();
        sauce = factory->createSauce();
    }
    void prepare() {
        std::cout << "Preparing pizza with " << dough->getName() << " and " << sauce->getName() << std::endl;
    }
};

```





