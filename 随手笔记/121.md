1.  [rust]

use validator::Validate;

如何 使用 rust的这个？



- 校验数字 范围

#[validate(range(min=18,max=100))]



- 校验url

#[validate(url)]



- 自定义

```rust
自定义函数签名必须固定
fn validate_unique_username(username: &str) -> Result<(), ValidationError> {
}
```

\#[validate(custom(function = "validate_unique_username"))]



- 递归校验 （结构体里面的结构体）

\#[validate(nested)]





2. [rust]

    如果我要限制用户 密码输入 
    比如 要有数字和字母且8位以上怎么写？

	什么是 once_cell?
	
- 因为 Rust 想要定义一个全局变量 它的初始化必须是一个常量表达式

  - 所以不能直接这么写: static RE_PASSWORD: Regex = Regex::new(r"^\d+$").unwrap();
  - 因为 Regex::new是运行的时候 确定 所以不能这么些

- ### `once_cell` 的作用

  `once_cell` 提供了“延迟初始化”的能力：

  1. **第一次访问时初始化**：变量只有在第一次被使用时，才会执行初始化代码（比如编译正则表达式、建立数据库连接）。
  2. **只初始化一次**：一旦初始化成功，后续所有访问都会直接拿到那个已经存在的值。
  3. **线程安全**：即使多个线程同时第一次访问，它也能保证初始化逻辑只运行一次，不会产生冲突

- ```rust
  static RE: Lazy<Regex> = Lazy::new(|| {
      println!("正则编译中..."); 
      Regex::new(r"^\d+$").unwrap()
  });
  ```





3. [rust]

```rust
rust的正则表达式的所有语法？
```

- `.` : 匹配除换行符以外的任何字符。
- `[abc]` : 匹配 a、b 或 c 中的任意一个。
- `[^abc]` : 匹配 **除** a、b、c 以外的任何字符。
- `[a-z]` : 匹配 a 到 z。
- `[a-zA-Z]` : 匹配不区分大小写的字母



- 量词

- `*` : 重复 0 次或更多次。
- `+` : 重复 1 次或更多次。
- `?` : 重复 0 次或 1 次。
- `{n}` : 恰好重复 n 次。
- `{n,}` : 至少重复 n 次。
- `{n,m}` : 重复 n 到 m 次





- `\d` : 数字，等同于 `[0-9]`。
- `\D` : 非数字。
- `\w` : 字母、数字、下划线，等同于 `[0-9A-Za-z_]`。
- `\W` : 非单词字符。
- `\s` : 空白符（空格、制表符、换行符）。
- `\S` : 非空白符





4. [rust]

Lasy 和 LasyLock 的区别

- 延迟初始化
- 线程安全
- 可以 在 static 中使用

- 推荐写法

```rust
use std::sync::LazyLock;
use regex::Regex;

static RE: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"^\d+$").unwrap());
```



5. [rust]

注册 成功 返回什么比较好
这个是 Qt前端 + rust后端的学习项目

用 jwt 或者 token这样处理么



- ```rust
  
  #[derive(Serialize)]
  struct re_response_data_user_info{
      id : i128,
      username: String, 
      name : String,
      avator: String
  }
  
  #[derive(Serialize)]
  struct re_response_data{
      token : String,
      userinfo : re_response_data_user_info
  }
  
  
  #[derive(Serialize)]
  struct re_response{
      code : String,
      message: String,
      data : re_response_data
  }
  
  ```

可以这样 递归 可序列化么



- 可以的





6. [rust]

```rust
use jsonwebtoken::{encode, Header, EncodingKey, Algorithm};
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,    // 用户名/ID
    exp: usize,     // 过期时间戳
}

fn create_jwt(username: &str) -> String {
    let my_claims = Claims {
        sub: username.to_owned(),
        exp: 10000000000, // 示例过期时间
    };
    let key = EncodingKey::from_secret("secret_key".as_ref());
    encode(&Header::default(), &my_claims, &key).unwrap()
}

```

生成 jwt



如何理解 这个 EncodingKey::from_secret？

如何理解 encode？

它们的函数签名是什么 参数需要怎么样？





- 在 Rust 的 `jsonwebtoken` 库中，`EncodingKey` 是你的**印章（密钥）**，而 `encode` 就是**加盖印章并装封的过程**

- pub fn from_secret(secret: &[u8]) -> Self

  - 在 Rust 中，你可以通过 `字符串.as_bytes()` 或者 `字符串.as_ref()` 把 `String` 或 `&str` 转成字节切片

- ```rust
  pub fn encode<T: Serialize>(
      header: &Header, 
      claims: &T, 
      key: &EncodingKey
  ) -> Result<String, Error>
  
  ```

  - **`header: &Header`**:
    - 定义加密算法。通常直接用 `Header::default()`，默认就是 `HS256`
  - **`claims: &T`**:
    - 这是你要存入 Token 的数据。
    - **要求**：这个类型 `T` 必须实现了 `serde::Serialize` 特性（因为它要被转成 JSON）
  - **`key: &EncodingKey`**:
    - 这就是上面通过 `from_secret` 创建出来的印章

- exp 就是当前时间 + 有效期











