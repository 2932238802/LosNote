1. [rust]

let db = Arc::new(Mutex::new(HashMap::new()));
详细介绍一下这个操作



- Mutex::new 互斥锁
- Arc::new 原子引用计数
- db.clone 只是在堆里面 生成一个新的指针 指向同一个空间



那这个 db的类型是啥
为啥 Mutex::new 里面的类型是这个
然后 Arc::new 里面的类型是这个？



- Mutex::new(HashMap::new)
  - 这个就是 装着哈希表的保险箱
- Arc 是一个智能指针
  - 指向内存中的某一个空间
- 所以 整个 就是 指向[装着哈希表的保险箱]的共享指针





2. [rust]

- 

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex}; 

#[tokio::main]
async fn main() {
    let db = Arc::new(Mutex::new(HashMap::new()));

    
    let db1 = db.clone(); 
    let t1 = tokio::spawn(async move {
        let mut data = db1.lock().unwrap();
        data.insert("hello".to_string(), "world".to_string());
        println!("任务1: 写入 hello = world");
    });

    let db2 = db.clone();
    let t2 = tokio::spawn(async move {
        let mut data = db2.lock().unwrap();
        data.insert("foo".to_string(), "bar".to_string());
        println!("任务2: 写入 foo = bar");
    });

    let _ = tokio::join!(t1, t2);

    let data = db.lock().unwrap();
    println!("--- 最终结果 ---");
    println!("hello: {:?}", data.get("hello"));
    println!("foo:   {:?}", data.get("foo"));
}

```



```rust
let t1 = tokio::spawn(async move {
    let mut data = db1.lock().unwrap();
    data.insert("hello".to_string(), "world".to_string());
    println!("任务1: 写入 hello = world");
});
```



所以 你之所以 这么操作是因为
不把db交出去的同时
把自己克隆的 db1 交出去 
异步用完 自动销毁 引用计数 -- 对么
所以要克隆
所以 要 move 对么



- 对的

- 当你写下 `async move { ... }` 时，编译器会悄悄扫描这个花括号里**用到了哪些外部变量**
- 因为你在花括号**里面**使用了 `db1`，编译器就自动判定：“这个闭包需要捕获 `db1`”。
- 如果没有 `move`，编译器默认是“借用” (`&db1`)
- 但是你加了 **`move`**，编译器就会说：“好，既然你里面用了 `db1`，那我就在创建这个任务的时候，把外面的 `db1` **直接移动**（Move）进这个任务的内存空间里。”

- 这就是 Rust 并发编程最经典的 **“Clone-Move”** 模式！你已经掌握精髓了

- [x] 1_18



- 不能用 借用
  - `main` 退出时，它的栈内存（包括 `db`）被清理销毁
  - 这叫 **“悬垂引用” (Dangling Reference)**，是 C/C++ 里最常见的内存安全漏洞来源。Rust 的借用检查器（Borrow Checker）在编译阶段就会直接拦截你





3. [rust]

![image-20260118153543897](D:\LosAngelous\LosNote\随手笔记\png\image-20260118153543897.png)

 let mut data = db_1.lock().unwrap(); 







4. [rust]

```rust
tokio::join!
是不是可以接受 多个 参数？
```



- 对的 
- 处理 多个 异步任务





5. 

let listener = TcpListener::bind("127.0.0.1:6379").await?;
详细介绍一下这个？

- .await 就是一个异步操作 

- 等待审批的异步操作

- 向操作系统 申请端口 是一个**系统调用** 虽然很快 但是对于CPU 是慢的

- `?` —— 报错机制

  这是一个 Rust 的语法糖（错误传播）。

  - **含义**：如果申请成功，就把 `listener` 拿出来；如果申请失败（比如端口被占用了，或者没权限），直接**立刻返回错误**（Return Err），让程序结束或报错，不要硬撑着往下跑





什么样的 表达式 可以用   "?"

- 表达式 本身返回 Result 和 Option
- **Result<T, E>**（最常见）：
  - 如果是 `Ok(数据)` -> `?` 会帮你拆包，把 `数据` 拿出来给变量。
  - 如果是 `Err(错误)` -> `?` 会**立即终止当前函数**，把 `错误` 抛给调用者。
- **Option**：
  - 如果是 `Some(数据)` -> 拿数据。
  - 如果是 `None` -> 立即返回 `None`











