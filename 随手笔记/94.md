1.  windows 的 ps1
   如何 查看一个项目里面的若干目录结构
   类似Linux的
   (tree -L 3 -I "node_modules")
   之类的指令



2.  [rust]

```rust
#[derive(Parser)]
#[command(name = "runner")]
#[command(about = "一个简单的万能代码运行器")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}
```

如何理解？



- `#[derive(Parser)]`  派生宏

  -  自动为下面的cli 结构体 实现parser这个trait这个接口
  -  一旦加上这个 cli 就自动拥有了 parse() 的方法 
     -  就会自动填入这个结构体的字段里

- #[command(name = "runner")]

  -  定义命令行工具的名字

- #[command(about = "一个简单的万能代码运行器")]

  -  用户输入 --help的时候 就会告诉用户这个工具是干嘛的

- #[command(subcommand)]
  - 子命令 






3. [rust]

#[derive(Debug)]
这个作用是？



- **自动让你的结构体（Struct）或枚举（Enum）支持被打印调试信息**







4. [rust]

use std::convert::TryFrom;
是专门给 枚举和结构体么？



- 答： 任何类型之间都可以用 `TryFrom`
- 大 转 小



5. 

```rust
let old = parts[1].trim().parse::<u16>().map_err(|_| ParseError)?;
```

- 匿名函数:
  - | | {}
  - 左边两个竖线是传参 
  - 右边的括号是函数体



如何理解 map_err

- 就是当发生错误的时候  将原来的错误类型转换成你自己定义的错误类型

- 比如一个函数 返回值 Result<T,u32> 错误必须是u32

  - 但是 调用 sqlx返回的是 sqlx::Error 

  - 所以类型不匹配  map_err 就像一个翻译官 

  - ```rust
    .map_err(|_| 500)
    ```

  - 如果是 ok 那么就直接跳过

  - 不ok 就不管它原来是什么 直接换成数字 500



- [x] 26_2_5



























