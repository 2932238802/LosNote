1. Qt的信号与槽机制是**线程安全的**

- [x] 11_19
- [x] 1_20



2. QThread::start()

- 请求操作系统创建一个新的执行线程
- 并在这个新线程调用 run方法
- 非阻塞的函数
- 让线程进入 “接受和处理事件/信号”的待命状态



3. 

connect(...) 是设置阶段：它在主线程执行，作用是建立一个连接。它告诉Qt：“如果A发生了，就通知B去做C”。
槽函数的执行是触发阶段：当信号被发射时，Qt会检查这个连接。如果发现发送者和接收者不在同一个线程，它就会自动采用一种叫做 Qt::QueuedConnection（队列连接） 的方式。这种方式的核心就是将函数调用封装成一个事件，发送到目标线程的事件队列中，由目标线程的事件循环来执行。

针对你这个 我要问几个问题：

所以 Connect的回调 本质 是有几个 过程？ 是先检查线程嘛？

如果这个函数 本身是在别的线程 但是我又想它在我这个线程 调用 那岂不是就没辙了？



- 答:

- 信号发射： 就是emit

- 查找订阅者： Qt的元对象系统会立刻查找内部的连接表，看看哪些槽函数订阅了这个信号

- 决定投递方式： 系统会遍历 每一个连接好的槽函数 并对每一个连接都进行决策 

  - 根据第五个参数 如果是autoconnect就是 判断一下线程是不是

- 执行投递： 对于直接连接的，不经过任何的中间环节，立即原地执行槽函数，对于队伍连接，将这个函数调用封装成一个QEvent事件，将这个事件放入到接收者所在线程的事件队列的末尾。**`Qt::AutoConnection`**   **`Qt::QueuedConnection`**

- [ ] 11_19



4. [rust]

```rust
fn main()
{
    let img = image::open("./test.bmp")?;

}
```

是这个代码
为什么 不可以用问好？



- 如果你的 `main` 函数定义是 `fn main()`，它默认的返回类型是 `()`（空）。你不能在一个返回空值的函数里 `return Err(...)`，这就像是在一个写明了“不收快递”的门口强行塞入一个快递包裹，系统（编译器）会直接报错





5. [rust]

- 打印图片的长和宽



```rust
    let img = image::open("./test.bmp")?;

    let (x,y)  = img.dimensions();
    println!("x: {}",x);
    println!("y: {}",y);
```











