1. [rust]

```rust

pub mod pb {
    // 对应 package auth_request
    pub mod request {
        include!(concat!(env!("OUT_DIR"), "/auth_request.rs"));
    }

    // 对应 package auth_response
    pub mod response {
        include!(concat!(env!("OUT_DIR"), "/auth_response.rs"));
    }
}
```

- rust 关于 protobuf的包含问题

- env!

  - Cargo 在执行 `build.rs` 时，会创建一个专门存放生成文件的临时目录。
  - 这个目录的路径非常长且随机（比如 `target/debug/build/项目名-hash/out`）。
  - `env!("OUT_DIR")` 就会返回这个具体的路径字符串

- ### `concat!`

  - 在编译的时候 把几个字符串串在一起

- include!

  - 在编译的时候 读取指定文件的路径
  - 并把这些内容 原封不动地替换到当前位置





2. [c++]

Ipv4Addr::UNSPECIFIED

- 0.0.0.0

- [x] 26_2_4



3.  [rust]

windows 本地测试 对接 sqliteSql

![image-20260205124955697](E:\LosNote\随手笔记\png\image-20260205124955697.png)



sqlx 的命令行 工具

```shell
cargo install sqlx-cli --no-default-features --features sqlite
```

创建迁移文件夹  +  在根目录运行下面这个指令


```shell
sqlx migrate add init_db
```

然后再编写这个 .sql文件 (生成在 migrations/dadah_init_db.sql)(所处在根目录下)

![image-20260205125421417](E:\LosNote\随手笔记\png\image-20260205125421417.png)

- [x] 26_2_5



```shell
cargo install sqlx-cli --no-default-features --features sqlite
如何理解？
 --no-default-features？
```

- 不采用 全部 组件下载下来的方式 就是安装一个 sqlite
- 因为 sqlx-cli 默认会把所有的 数据库驱动都打包下来

- [x] 26_2_5



4. 

```rust
use bcrypt::verify;
```

- 哈希解密
- 可以 直接使用 verify 进行哈希解密

- [x] 26_2_5

- [x] 26_2_12



5. 

```rust
pub async  fn lo_controller(
    State(state):State<AppState>,
    body : Bytes
)
    -> impl  IntoResponse
{
}
如何理解 这个  impl  IntoResponse？
函数如果这么声明返回值 那么是不是意味着 就是 任何满足 IntoResponse的结构体都能被返回？
```

- 整个 impl 就是告诉编译器 这个函数会返回一个具体的类型 这个类型保证了 实现了 IntoResponse  协议但我不想在函数签名里面写出它的真实长名字，需要编译器自己推到

- [ ] 26_2_5



6. ECS 设计模式的好处

ECS 的快并不是因为代码写得精妙，而是因为它**顺应了现代硬件的底层规律**。它通过 **DOD (Data Oriented Design，数据导向设计)** 极大化地利用了 CPU 缓存，规避了指针追踪带来的 Cache Miss，并且天然适配 SIMD 和多线程并行

- [x] 26_2_12


















