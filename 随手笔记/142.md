1. [C++]

list 的学习



```c++
    std::vector<int> contain{1,2,3};
    std::list<int> list_(contain.begin(),contain.end());
```

- 可以通过 其它迭代器进行构造

- [x] 26_2_1





```c++
auto it1 = vec.begin() + 3;      // 正确
auto it2 = vec.begin();
std::advance(it2, 3);            // 正确

// 对于双向迭代器，只能用advance
// auto it3 = lst.begin() + 3;  

为啥这个编译错误？
```

- 因为 这个 `std::list`, `std::set`, `std::map` 是双向迭代器
  - 非连续内存（链表节点、红黑树节点）
  - 只支持 `++`, `--`。**不支持 `+` 和 `-`**
  - 链表节点散落在内存各处。要找到第 3 个节点，必须从当前位置开始，沿着 `next` 指针一个一个跳
- ***O\*(\*n\*)**





```C++
template <class InputIterator, class Distance>
void advance(InputIterator& it, Distance n);
```

- advance

- ```c++
  auto it = lst.begin();
  std::advance(it, 3); // it 现在指向第四个元素
  ```

- ```c++
  auto it = std::next(lst.begin(), 3); // 相当于 it = lst.begin() + 3
  ```





```c++
    for(auto a: list_)
    {
        std::cout << a << " ";
    }    
    std::cout << std::endl;

    // 0 10 1 2 3 3 -1
    auto next = std::next(list_.begin() , 3);
    // 输出了 2
```

- std::next 的使用

  



2. 

unordered_map 如何 判断一个键值对 存不存在？

- ```c++
  std::unordered_map<int, std::string> map = {{1, "apple"}, {2, "banana"}};
  
  auto it = map.find(1); 
  if (it != map.end()) {
      // 存在
      std::cout << "找到了: " << it->second << std::endl;
  } else {
      // 不存在
      std::cout << "没找到" << std::endl;
  }

- 常规的find思路



```c++
if (map.contains(1)) {
    // 存在
}

```

- 这个思路 如果 要取出 对应的 value 还要 两次 哈希计算



```c++
if (map.count(1)) {
    // 存在 (count 返回 1，逻辑为真)
}
```

- 最简单的方式



3. 

详细介绍一下 C++的 list的 splice？

```c++

```

- 拨弄四个指针的 指向
  - 只是在链表中的逻辑顺序发生改变了
  - void splice(const_iterator pos, list& other);
    - 将 `other` 里的所有元素剪切，粘贴到当前 list 的 `pos` 之前。
  - void splice(const_iterator pos, list& other, const_iterator it);
    - 将 `other` 中由 `it` 指向的那个元素剪切，粘贴到当前 list 的 `pos` 之前。
  - void splice(const_iterator pos, list& other, const_iterator first, const_iterator last);
    - 将 `other` 中 `[first, last)` 范围内的元素剪切，粘贴到当前 list 的 `pos` 之前

- [x] 26_2_5



4. LRU的缓存这个 怎么写

```c++
#include <unordered_map>
#include <list>
#include <iostream>
#include <utility>

class LRUCache {
    int capacity;
    std::list<std::pair<int, int>> list_;
    std::unordered_map<int, std::list<std::pair<int, int>>::iterator> map_;

public:
    LRUCache(int capacity) : capacity(capacity) {}
    
    int get(int key) {
        auto it = map_.find(key);
        if (it == map_.end()) {
            return -1;
        }
        
        list_.splice(list_.begin(), list_, it->second);
        
        return it->second->second;
    }
    
    void put(int key, int value) {
        auto it = map_.find(key);
        
        if (it != map_.end()) {
            it->second->second = value;
            list_.splice(list_.begin(), list_, it->second);
            return;
        }

        if (list_.size() == capacity) {
            int last_key = list_.back().first;
            map_.erase(last_key);
            list_.pop_back();
        }

        list_.emplace_front(key, value);
        map_[key] = list_.begin();
    }
};
```





5. vector 初始化 unordered_map

```c++
#include<vector>
#include<unordered_map>

int main(){

    std::vector<int> contain{1,3,5};
    std::unordered_map<int, int> map_(contain.begin(),contain.end());
    return 0;
}

map_ 里面每个值都是0么？
```





