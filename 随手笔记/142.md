1. condition_variable

```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
int state = 0; 

void printLetter(char c, int target_state) {
    for (int i = 0; i < 10; ++i) { 
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, [target_state] { return state == target_state; });
        std::cout << c;
        state = (state + 1) % 3;
        cv.notify_all();
    }
}

int main() {
    std::thread t1(printLetter, 'A', 0);
    std::thread t2(printLetter, 'B', 1);
    std::thread t3(printLetter, 'C', 2);
    t1.join();
    t2.join();
    t3.join();
    std::cout << std::endl;
    return 0;
}
```

 对于这个 代码里面的 详细介绍一下 这个 wait函数 notify_all?



- #### 判断“入睡”条件（谓词 Predicate）

  - `wait` 首先执行 Lambda 表达式 `[] { return state == target_state; }`。
  - **如果返回 `true`**：线程认为条件满足，**不阻塞**，直接向下执行。
  - **如果返回 `false`**：线程进入第 2 步。

- 原子性的“放锁 + 睡觉” (关键！)

  - 线程会自动做两件事：**释放 `mtx` 互斥锁**，同时把自己的**线程挂起（阻塞）**，进入等待队列。
  - **为什么要放锁？** 如果它不放锁就去睡觉，别的线程就永远拿不到锁，也就没法修改 `state`，这就死锁了。
  - **为什么要原子性？** 为了保证在“决定睡觉”和“真正睡着”之间，不会错过任何通知。

- 醒来后的“抢锁”

  - 当其他线程调用 `notify_all()` 时，这个线程被唤醒。
  - **醒来后的第一件事不是打印**，而是**重新竞争 `mtx` 锁**。
  - 只有抢到了锁，`wait` 才会再次执行 Lambda 表达式：
    - 如果条件依然不满足（虚假唤醒），它会重复第 2 步（放锁接着睡）。
    - 如果条件满足，`wait` 彻底结束，代码向下执行

- [x] 26_1_29



2. 

```c++
#include <iostream>
#include <thread>
#include <semaphore> // C++20 标准

// 定义三个信号量
// semA 初始值为1（先开始），其他为0
std::counting_semaphore<1> semA(1);
std::counting_semaphore<1> semB(0);
std::counting_semaphore<1> semC(0);

void printA() {
    for (int i = 0; i < 10; ++i) {
        semA.acquire(); // 等待 A 信号
        std::cout << "A";
        semB.release(); // 释放 B 信号
    }
}

void printB() {
    for (int i = 0; i < 10; ++i) {
        semB.acquire();
        std::cout << "B";
        semC.release();
    }
}

void printC() {
    for (int i = 0; i < 10; ++i) {
        semC.acquire();
        std::cout << "C";
        semA.release();
    }
}

int main() {
    std::thread t1(printA);
    std::thread t2(printB);
    std::thread t3(printC);

    t1.join();
    t2.join();
    t3.join();
    return 0;
}

如何理解 
这个 sem 是 0 还是 1
难道 是1 就是可以还是说 > 1就可以？
```



- 信号量内部维护一个**计数器（Counter）**：
  - **`acquire()` (请求令牌)**：
    - 如果 计数器 **> 0**，就把计数器 **减 1**，然后线程继续往下走。
    - 如果 计数器 **== 0**，线程就**原地睡觉（阻塞）**，直到有人把计数器变大。
  - **`release()` (归还令牌)**：
    - 把计数器 **加 1**。
    - 如果有线程正在睡觉等这个信号量，叫醒它

- [ ] 26_1_29



counting_semaphore
为什么 要 <1> ?
如何理解？

- `<1>` 定义了该信号量的**“容量上限**

- [x] 26_1_29



3. 常规的 CMakeLists的编写

```cmake
cmake_minimum_required(VERSION 3.8)

project(MyApp VERSION 1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

add_executable(test test.cpp)
find_package(Threads REQUIRED)
target_link_libraries(test PRIVATE Threads::Threads)

```

- [x] 26_1_29
