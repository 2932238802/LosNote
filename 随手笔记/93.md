1. 

```c++
ui->dirBtn->setIcon(QIcon(ICON_PATH::NEW_FOLDER));
ui->dirBtn->setIconSize(STEP_THREE_TOOL_ICON_SIZE);
```



- 这个方式就可以 设置对应的图标





2. 

 	QRectF rectInItem = item.item->mapRectToParent(item.item->boundingRect());
这个函数的设计很奇怪
为什么 要 传一个本身的 boundingRect? 不能直接在函数内部 this->bonudingRect?



- 但 `mapRectToParent` 这个函数之所以**必须**传参，是因为它的设计初衷是一个**通用的数学转换工具**，而不是一个单纯的“属性获取器”。

- 如果这个函数设计成不传参（默认只转 boundingRect），那么 Qt 就不得不提供两个函数：

  1. `getBoundingRectInParent()` (无参)
  2. `mapRectToParent(rect)` (有参)

  为了保持 API 的精简，Qt 选择只提供一个最通用的 `mapRectToParent`，让你自己决定传什么进去



<<<<<<< HEAD
=======


3.  [安卓]

Runnable
是一个什么类？

- 这个是一个 接口
- 



4. 

        SharedPreferences appPrefs = getSharedPreferences("AppSettings", Context.MODE_PRIVATE);

如何理解 Context.MODE_PRIVATE？



- 这个文件是私有的 只有我的app才能访问



5. [安卓]

private Handler quoteHandler = new Handler(Looper.getMainLooper());

如何理解 Hander？



- 







>>>>>>> 49630d6b05d6769c9abe36610640d63a7cdc5216
