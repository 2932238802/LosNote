1. 

```rust
let (tx, mut rx1) = broadcast::channel(10);
如何理解？
详细介绍？
```

- 本质是一个 通信管道
- 多生产者 多消费者
- 返回值是一个元组 (Sender<T>, Receiver<T>)
- **`Sender<T>` 的本质**： 它内部包含一个 `Arc<Shared<T>>`。
  - `Shared<T>` 是那个存数据的环形 Buffer。
  - 因为是用 `Arc` 管理的，所以 `Sender` 可以被无限 `clone`，每克隆一次只是引用计数 +1，**极其廉价**。
  - 这就是为什么每个连接进来的 TCP 线程都能拿一个 `Sender` 副本。
- **`Receiver<T>` 的本质**： 它包含两部分数据：
  1. `Arc<Shared<T>>`：指向同一个共享 Buffer（为了读数据）。
  2. `u64` (Atomic/Cell)：**游标 (Cursor)**，记录“我当前读到第几条了”
- broadcast::channel 本质是一个 工厂函数
- 这里的10 是 **第 11 条消息** 会直接覆盖掉 **第 1 条消息** 所在的内存位置
  - 就是 预留空间 环形缓冲区的容量

- [x] 1_18



这个 环形缓冲区 是
这两个句柄 各自占有 10个位置的意思么
还是 两个加起来是 10个？
那 如果 一个用完了呢？
还有为什么 发送者 不是 mut？

- 不要被 `Sender` 和 `Receiver` 这种“手柄”迷惑了。

  - **内存里**：只有一个真实的、物理存在的环形数组，长度为 10。
  - **手柄里**：Sender 和 Receiver 手里拿的只是**指向这个数组的指针**（`Arc`）。

  不管你克隆了 1000 个 Sender，还是订阅了 10000 个 Receiver，它们所有人围观的、操作的，都是**同一个**大小为 10 的数组

- 因为 发送者 没有任何需要改的内部字段 但是 读者 有

- [x] 1_18







2. 
   为什么 socket 可以被 split？

   tokio::select! 本质是什么？

- struct TcpStream {

    fd: FileDescriptor, // 只有一个！

  }

- 不是因为 里面有两个 才可以被split

- 这是 Tokio 的开发者专门为它写了一个名为 `split()` 的方法

- tokio::select!  它不会死等 A 做完再看 B。它是**快速地问一遍 A，再问一遍 B**

  - 可以支持 64个分支
  - 会同时盯着 N个任务 谁先完成选谁

- [x] 1_19



3. 

```rust
loop {
    // 关键在于里面的 await
    tokio::select! { ... }.await; 
}
```



这个 门铃响了的操作
是哪里 提醒了这个程序
或者说 这个程序 被哪段代码 唤醒
这个唤醒的 底层是什么



- 当你的程序 `await` 挂起时，实际上是对应的线程调用了类似 `epoll_wait` 的系统调用，并在那里**阻塞（Block）**住了，完全交出了 CPU 控制权
- Rust 的 `tokio` 运行时里，有一个专门的组件叫 **Reactor**。它就像是那个去和内核打交道的“管家”。
  1. 当你的代码执行到 `socket.read().await` 时：
     - Tokio 会把这个 Socket 的 ID (FD) 注册给 Reactor
     - 并留下一个联系方式，叫 **Waker (唤醒器)**
  2. 然后你的任务就返回 `Pending`，去睡觉了
-  **网卡 -> 操作系统中断 -> epoll -> Tokio Reactor -> Waker**





4. 

![image-20260118210655787](D:\LosAngelous\LosNote\随手笔记\png\image-20260118210655787.png)



- [x] 1_18
- [x] 1_19



5. 

![image-20260118211216752](D:\LosAngelous\LosNote\随手笔记\png\image-20260118211216752.png)



- 这个 reader 是 裸指针 

  - 如果你读 1000 个字节分 1000 次读
  - 为什么 如果你读 1000 个字节分 1000 次读？
    不懂 裸指针 read 不能一次性读多个么？
    当初设计的时候 直接设计成多个不行么？
    我的 C 语言也是 可以 一次性读多个的？
  - 因为 这里 可能存在 \n 所以要多次读取

- `BufReader::new(reader)` 做的事情是：**把裸水管包进了一个带缓冲区的桶里**。

  当你现在喊“读一行”时：

  1. `BufReader` 会先去操作系统那，**一口气** 捞一大勺数据（比如 8KB）存到自己的肚子里（内存 Buffer）。
  2. 然后在内存里飞快地检查这堆数据哪里有换行符。
  3. 把这一行给你。
  4. 剩下的数据留着下次用















