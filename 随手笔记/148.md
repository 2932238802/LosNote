1. [rust]

- into_response 
  - 就是包装成axum::response::Response

- [ ] 26_2_5

```rust
    match lo_service::login_service(&state.pool, req).await{

        Ok(data) =>{
            res.code = 200;
            res.message = "登录成功".into();
            res.data = Some(UserData{
                token: data.token,
                username : data.username,
                avatar : data.avatar,
                created_at : "".to_string(),
            });
        }
        Err(code)=>{
            res.code = code as i32;
            res.message = match code {
                500 =>{
                    "服务器错误".to_string()        // 这里的 to_string 就是让编译器 自动推导
                },
                401=>{
                    "用户名错误".into()
                }
                404 =>{
                    "用户不存在".into()
                }
                _=>{
                    "未知错误".into()
                }
            };
            res.data = None;
        }
    }
```





2. [rust]

```rust
use server_rust::net::serve;
use dotenvy::dotenv;
fn main() {
    // 获取 根目录下的 .env么?
    dotenv().ok();
}

```



- 对的 默认就是寻找项目根目录的 .env 文件

- [ ] 26_2_5



那么 这个 dotenv如何获取指定目录下的文件呢

```rust
use dotenvy::from_path;

fn main()
{
    let path = Path::new("config/.env.dev");
    from_path(path).expect("未能找到指定文件")
}
```





3. 

```rust
use server_rust::net::serve;
use std::env;
use dotenvy::dotenv;
fn main() {
    dotenv().ok();
    let database = env::var("DATABASE_URL").unwrap();
    
}
1. 为什么 这个 dotenv和std::env 要分开两个包 这两个本质不就是一个初始化另一个么？
2. 只有调用这个 dotenv 才能用这个 env::var啊？ 为啥不直接在std::env::dotenvy实现呢？
3. 难道也是 积木块？ 这个积木块故意这么做的？ 还是说std 内部其实有实现 但是 dotenvy更好？
```

- dotenvy 就是把指定文件里面的内容 读取到当前进程的环境变量里面
- 对于 第二个问题就是说 体现了 Rust的极简标准库
- 第三方库 一直在迭代 防止标准库 太臃肿



4. 

```rust
    let pool = SqlitePoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;

这个是创建 sqlite的线程池么
```

- 创建的是连接池
- 内存中 打开了 5个数据库文件句柄



5. 

```rust
let redisManager = RedisConnectionManager::new(redis_url.clone())?;
    let redis_pool = bb8::Pool::builder()
        .max_size(15)
        .build(redisManager)
        .await?;

这两个包也是 积木关系么
```





6. [rust]

```rust
pub async  fn api_router(ctx:AppState) -> Router
{
    Router::new()
        .route("api/auth/login", post(lo_controller))
        // .route("api/auth/code", post())
        // .route("api/auth/register", post())
        .layer( CorsLayer::new()
                .allow_origin(Any)
                .allow_methods(Any)
                .allow_headers(Any)
            )
        .with_state(ctx)
}

这个 with_state 需要的是一个结构体么？
```

这个 with_state 需要的是一个 实现了 clone的结构体 或者实现了clone即可

- [x] 26_2_7
- [x] 



7. 

```c++
QByteArray RegisterRequest::body() const
{
	QByteArray data;
	size_t size_ = static_cast<size_t>(LOS_request.ByteSizeLong());
	data.resize(size_);
	LOS_request.SerializeToArray(data.data(), size_);
	return QByteArray(data.data(), data.size());
}

这里的 返回为什么 不可以直接 返回 data？
还要 这样子？
还有这个 Serialize的函数我看了 有很多
有个partitial 是什么用的？
```

- 在 proto3 里已经取消了 required，常用的就是 SerializeToArray/ParseFromArray

- “Partial” 就是不去强制检查“必选”字段这种额外约束，在有 required 情况下可以用它绕开检查

- ```c++
  QByteArray RegisterRequest::body() const
  {
      QByteArray data;
      data.resize(LOS_request.ByteSizeLong());
      LOS_request.SerializeToArray(data.data(), data.size());
      return data;              // 直接返回，拷贝整个 buffer，安全且一目了然
  }
  ```

  - 这么写也是对的
  - 但是 return data.data(); 这样子是错的 会发生截断







