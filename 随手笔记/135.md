1. C++多态的实现方案

第一层：分类（展现知识体系的完整性）
首先说明 C++ 多态分为两种：

1. **静态多态（编译期）：** 主要通过 **函数重载（Overload）** 和 **模板（Template）** 实现。优点是效率高，没有运行期开销。
2. **动态多态（运行期）：** 主要通过 **虚函数（Virtual Function）** 实现

- [x] 26_1-28
- [x] 26_1_29
- [x] 26_1_28
- [x] 26_2_3




第二层：动态多态的底层实现（核心：虚表指针与虚表）

1. **虚函数表 (vtable)：**
   - 编译器为每个包含虚函数的类创建一个唯一的虚表。
   - 虚表本质上是一个**函数指针数组**，存储着该类所有虚函数的地址。
   - 对于重写（Override）了父类的虚函数，虚表中对应的条目会被子类的函数地址覆盖。

- [x] 26_1_28
- [x] 26_1_29
- [x] 26_1_29



1. **虚表指针 (vptr)：**
   - 当类中包含虚函数时，编译器会在该类的**每个对象实例**的内存布局开头（通常是前 4 或 8 字节）插入一个隐藏的指针，指向该类对应的虚表。

- [x] 26_1_28
- [x] 26_1_29



1. **调用过程（寻址过程）：**
   - 通过父类指针调用虚函数时，程序执行以下步骤：
     1. 根据对象内存头部的 **vptr** 找到 **vtable**。
     2. 根据该虚函数在表中的 **偏移量（Offset）** 找到具体的函数地址。
     3. 跳转到该地址执行代码。
   - *面试话术：* “这是一种**间接寻址**的过程。”

- [x] 26_1_28





2. 在使用虚函数的时候如何保证析构的正确性？

为了保证析构正确性，我会确保**基类析构函数被声明为 `virtual`**，这样可以利用虚函数的动态绑定机制，确保在通过基类指针删除对象时，派生类的资源能被正常释放

- [x] 26_1_28
- [ ] 



3. 动态的绑定的三个要素

1. **虚函数：** 基类中该函数必须声明为 `virtual`。
2. **继承/重写：** 子类必须覆盖（Override）这个虚函数。
3. **指针或引用：** 必须通过**基类的指针或引用**来调用该函数。

- [x] 26_1_28

动态绑定是 C++ 实现运行时多态的机制。它通过虚函数表实现，将函数地址的确定推迟到运行期。

当通过基类指针调用虚函数时，程序会根据对象内存中的虚表指针（vptr）找到实际类的虚表，再根据偏移量定位并执行正确的函数。这种机制虽然提供了灵活性，但也引入了间接寻址的开销并阻碍了编译器内联优化，因此在引擎的高频性能瓶颈处（如 Tick 循环）需要谨慎使用





4. 

父类指针如何正确调用子类的析构函数

父类指针要正确调用子类的析构函数，**基类的析构函数必须声明为 `virtual`**。

```c++
class Base {
public:
    virtual ~Base() { /* ... */ } // 必须是 virtual
};

class Derived : public Base {
public:
    ~Derived() { /* 释放子类特有资源 */ }
};

Base* ptr = new Derived();
delete ptr; // 此时能正确触发 Derived 的析构
```

- [ ] 26_1_28



底层原理：从静态绑定到动态绑定

- **如果不加 `virtual`（静态绑定）：** 编译器在处理 `delete ptr;` 时，只看到 `ptr` 的类型是 `Base*`。由于析构函数不是虚函数，编译器会直接硬编码调用 `Base::~Base()` 的地址。
  - **结果：** 只有父类部分被销毁，子类特有的成员（如 `std::vector` 或申请的堆内存）完全没有被清理，导致**内存泄漏**。
- **如果加了 `virtual`（动态绑定）：** 析构函数的地址会被放入**虚函数表（vtable）**中。执行 `delete ptr;` 时：
  1. 程序通过对象的 `vptr`（虚表指针）找到虚表。
  2. 从虚表中取出实际指向的对象（`Derived`）的析构函数地址。
  3. 执行子类的析构函数。

- [ ] 26_1_28



5. 

子类析构函数执行完了，父类部分怎么销毁？

你需要明确：**析构函数的调用是链式的，且顺序与构造函数相反。**

1. 首先调用 **最派生类（Most Derived）** 的析构函数。
2. 执行完子类析构函数的代码体后，它会自动调用其直接父类的析构函数。
3. 这个过程一直向上持续，直到到达基类

- [x] 26_1_29
- [x] 26_2_3

