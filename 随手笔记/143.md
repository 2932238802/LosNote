

2. vector的底层

- 连续的内存块
- 三个指针 数组头 最后一个元素的下一个位置 指向已分配内存的末尾

- [x] 26_1_30



3. 

vector 的 clean 函数会不会释放内存 ？

- 不会
- 它将 `vector` 的 `size()` 重置为 0

- [x] 26_1_29



4. 

虚函数表（vtable）的原理是什么

编译器会为带虚函数的类生成一个虚函数表，对象内存中包含一个虚表指针（vptr），调用时根据指针找到实际函数地址



- [x] 26_1_29



5. 

Qt 的信号与槽（Signal & Slot）机制是怎么回事？它是线程安全的吗

- 一种对象间通信的方式。底层通过元对象编译器（MOC）实现
- 松耦合
- 取决于连接类型。如果是 `QueuedConnection`，它会自动通过事件队列跨线程通信，是线程安全的

- [x] 26_1_29



6.  Qt的信号 的线程安排

connect(sender, &Sender::signal, receiver, &Receiver::slot, Qt::QueuedConnection);

默认是 `Qt::AutoConnection`。如果发送者和接收者在同一个线程，它会自动变成 `DirectConnection`（直接调用）；如果在不同线程，它会自动变成 `QueuedConnection`

- [x] 26_1_29



7. 

```shell
git add .
git commit -m "1_2"
git merge -分支
发生错误
git add "错误文件"
git commit "修正冲突"
git remote add origin "http"
git branch -M main
git push -u origin main
```

- [ ] 26_1_30





8. 

如果要vector要释放内存的话应该怎样做？

- std::vector<int> v = {1, 2, 3, 4, 5};

  std::vector<int>().swap(v); 



9. 

vector 的什么操作会引发迭代器失效的问题？

**`erase`, `pop_back`**，**`insert`**

当 `vector` 的 `size` 超过当前的 `capacity` 时，它会重新申请一块更大的内存，把旧数据搬过去，然后释放旧内存

```c++
for (auto it = v.begin(); it != v.end(); ) { // 注意这里不写 ++it
    if (*it == target) {
        it = v.erase(it); // 更新迭代器，指向被删元素的下一个
    } else {
        ++it; // 没删除时才手动递增
    }
}
```





10. 

```c++
#include <condition_variable>
#include <iostream>
#include <mutex>
#include <thread>

std::mutex mtx;
std::condition_variable cv;
int state = 0;

void func(char c, int stat) {

  for (int i = 0; i < 3; i++) {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, [stat]() { return stat == state; });

    state = (state + 1) % 2;
    std::cout << c << " " << std::endl;
    cv.notify_one();
  }
}

int main() {
  std::thread t1(func, 'a', 0);
  std::thread t2(func, 'b', 1);

  t1.join();
  t2.join();

  return 0;
}
```

- [ ] 26_1_30



因为 `condition_variable` 在等待时需要**反复地进行解锁和重新加锁**的操作。

1. 当线程进入 `wait` 并发现条件不满足时，它必须**立即释放锁**，以便其他线程能拿到锁并修改条件。
2. 当线程被唤醒并准备返回时，它必须**重新拿到锁**。 `lock_guard` 太过简单，不具备手动解锁（unlock）和加锁（lock）的能力，而 `unique_lock` 提供了这些灵活的接口，所以 `wait` 必须配合 `unique_lock` 使用

- [ ] 26_1_30



11. [.clangd]

```yaml
CompileFlags:
  Add:
    - "-std=c++20"
    - "Wall"       # 开启所有警告
```

- 这个标志 C++ 20的标准 进行

- [ ] 26_1_30



这能在屏幕上**虚显**出变量类型和函数参数名，非常适合面试时看代码

```yaml
InlayHints:
  Designators: Yes
  Enabled: Yes
  ParameterNames: Yes  # 显示函数调用的参数名，比如 func(count: 10)
  DeducedTypes: Yes    # 显示 auto 的实际类型
```

- [ ] 26_1_30





```yaml
Index:
  Background: Build # 开启后台索引，方便在大型项目中跳转（Go to Definition）
```

- [ ] 26_1_30

















