1. to_owned
   如何理解？

- let my_claims = Claims {

  ​    sub: username.to_owned(), // 这里的 username 是借来的 &str

  ​    exp: 10000000000,

    };

- **结构体要求 `String`**：你的 `Claims` 结构体定义中，`sub` 字段的类型是 `String`。`String` 是一个“拥有所有权”的类型，它需要把数据存在自己的内存里
- 把 **`&str`**（字符串切片/借用）转换成 **`String`**（拥有的字符串）





2. 

```rust
EncodingKey::from_secret
的两个参数是什么
是从.env文件读取的么 还是环境变量 比如 dockerfile 里面的 ENV？
```



- pub fn from_secret(secret: &[u8]) -> Self



3. [rust]

```rust
我的外层docker是
version: '3.8'
services:
  lostrans-backend:
    build:
      context: ./backend-rust
      dockerfile: Dockerfile
    container_name: lostrans-app
    ports:
      - "3000:3000"
    volumes:
      - ./backend-rust/data:/app/data
    environment:
      - DATABASE_URL=sqlite:/app/data/lostrans.db
      - RUST_LOG=info
      - API_URL=https://fanyi-api.baidu.com/api/trans/vip/translate
      - API_ID=20251105002491626
      - API_SECRET=WAlmxIahPOYvd8APj6_b
      - API_KEY=zjcy_d5pi1ak7jonrr0o5vlk0
    restart: always


那么 这个sql文件要建立在哪里
是内层的dockerfile还是外层
然后 关于 用户的表 要怎么写呢？
```



- project_root/
  ├── docker-compose.yml
  └── backend-rust/
      ├── src/
      ├── migrations/             <-- 建议建立这个文件夹
      │   └── 20240101_init.sql   <-- 你的建表语句
      ├── data/                   <-- 挂载点，.db 文件会生成在这里
      └── Dockerfile

- ```sql
  CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT, -- SQLite 自动增量 ID
      username TEXT NOT NULL UNIQUE,        -- 邮箱/账号（唯一索引）
      password TEXT NOT NULL,               -- 存储 bcrypt 加密后的哈希值
      name TEXT,                            -- 用户昵称
      avatar TEXT DEFAULT 'default.png',    -- 头像文件名或 URL
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP -- 注册时间
  );
  
  CREATE UNIQUE INDEX IF NOT EXISTS idx_users_username ON users(username);	-- 加快查询速度
  ```









4. [docker]

WORKDIR /app

是把 dockerfile 所在的目录 名字取为 /app嘛？



- 你可以把它理解为在容器里执行了 `mkdir /app` 加上 `cd /app`

- [ ] 1_24



FROM debian:bookworm-slim
这个是什么意思？

- **请使用 Debian Linux 第 12 版（代号 Bookworm）的精简版（Slim）作为我运行环境的基础**





5. 

```dockerfile
FROM rust:1.85-slim AS builder

RUN apt-get update && apt-get install -y \
    pkg-config \
    libssl-dev \
    libsqlite3-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY Cargo.toml Cargo.lock ./
RUN mkdir src && echo "fn main() {}" > src/main.rs && cargo build --release

COPY src ./src
RUN touch src/main.rs && cargo build --release

FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y \
    libsqlite3-0 \
    libssl3 \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY --from=builder /app/target/release/backend-rust ./backend

RUN mkdir -p /app/data

ENV DATABASE_URL=sqlite:/app/data/lostrans.db
ENV RUST_LOG=info
ENV JWT_KEY=gW3qG0qF

EXPOSE 3000

CMD ["./backend"]

为什么 上面已经 FROM了 下面还要 FROM？
```

- FROM rust:1.85-slim AS builder
  COPY --from=builder

  根据这两个 我的理解是 第一个 也可以取名为 builder2？
  这样的话 第二个 COPY 就不会复制错？



所以 最终的 编译环境 取决于
哪个 FROM的后面没有as？

- 不对

- #### 最后一个才是“赢家”

  Docker 会按顺序执行指令。每一个 `FROM` 都会开启一个新的阶段。当 Docker 处理完整个文件后，它会把**最后一个阶段**的内容打包成最终的镜像











