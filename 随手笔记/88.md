1. 

qt里面安全的强制类型转换是？

qobject_cast 强制类型转换

如果转换失败 就返回 nullptr



- [x] 26_1_4
- [ ] 



T *qobject_cast<T *>(QObject *object)

不需要 RTTI（运行时类型识别）

这是它与标准 `dynamic_cast` 最大的区别：

- `dynamic_cast` 依赖于编译器的 RTTI（通常会增加二进制文件体积）。
- `qobject_cast` 依赖于 Qt 的**元对象系统 (moc)**。即使在禁用编译器 RTTI 的情况下，它依然能正常工作

- [ ] 26_1_27



它运行的时候是安全的

返回0或者是nullptr 如果失败的话

- [ ] 26_1_27



2. 

​	class ReviewRectItem : public QObject, public QGraphicsRectItem

问： 为什么继承了一个还要继承一个？



-  因为 RectItem 是一个 有形状的
- 所以不能直接继承 QGraphicsObject  因为这个没有形状

- [ ] 26_1_27



3. 

```c++

namespace NS_HsStepOneWidgetUi
{
	class ReviewRectItem : public QObject, public QGraphicsRectItem
	{
		Q_OBJECT
	public:
		using QGraphicsRectItem::QGraphicsRectItem;
	protected:
		QVariant itemChange(GraphicsItemChange change, const QVariant& value) override;
		void mouseReleaseEvent(QGraphicsSceneMouseEvent* event);

	signals:
		void _rectMove();	// 矩形移动
	};
};
```

如何理解这个 using QGraphicsRectItem::QGraphicsRectItem; 使用父类的构造方法？



- 答：声明：父类 QGraphicsRectItem 的所有构造函数，我这里都能直接用

- [x] 26_1_27

```c++
class Father {
protected:
    void secretSkill() { /* 祖传秘方 */ }
};

class Son : public Father {
public:
    // 把爸爸藏起来的技能公开给大众使用
    using Father::secretSkill; 
};
```

```c++
class Father {
public:
    void say(int i) { /* 处理整数 */ }
};

class Son : public Father {
public:
    // 子类写了一个同名函数，但参数是字符串
    void say(QString s) { /* 处理字符串 */ }
};

// --- 调用 ---
Son s;
s.say("hello"); // ✅ 没问题，调用的是 Son::say(QString)
s.say(123);     // ❌ 报错！
// 编译器会说：找不到匹配的函数。
// 因为 Son::say 把 Father::say(int) 给“挡住”了，编译器只看得到 Son 里的东西。

```

```c++
class Son : public Father {
public:
    // 这句话的意思是：把爸爸所有的 say 函数都拿到我这里来，和我的一起用！
    using Father::say; 

    void say(QString s) { /* ... */ }
};

// --- 调用 ---
Son s;
s.say("hello"); // ✅ 没问题
s.say(123);     // ✅ 没问题！现在能看见 Father::say(int) 了

```





4.  [Qt]

this->setCursor(QCursor(pix, 0, 31));

如何理解后面两个参数

后面两个参数是设置 橡皮擦的热点

铅笔和钢笔一般是左上角 0,0

橡皮一般是左下角

- [x] 26_1_6
- [x] 26_1_27
- [ ] 





5. 

constexpr 为什么不能和QString组合？

因为 QString 需要在“运行时”分配堆内存（Heap Memory），而 constexpr 要求所有的计算和初始化必须在“编译时”完成

- [x] 26_1_6
- [x] 26_1_27
- [ ] 



cmake -G "Visual Studio 15 2017" -A x64 -DCMAKE_PREFIX_PATH="D:/Qt/5.15.2/msvc2015_64" ..

- 指定版本信息的写法

- [ ] 26_1_27









