1. 

QByteArray::mid(int pos, int len = -1) const

- pos 是从哪个位置开始
- len 是 剪多长
  - 默认是 -1 剪到末尾



2. [c++]

reinterpret_cast 和 static_cast的区别是？

- static_cast 是理智转换 编译器 会检查是否合法
- reinterpret_cast 不检查 完全信任程序员 



3. [C++ Qt]

QTcpSocket
的 disconnectFromHost
和 abort的区别是什么？

```c++
abort() 是 粗暴 强制关闭 瞬间完成 立即释放
disconnectFromHost 是温柔的完成对应的 关闭 等待 发送完毕
```





4. [git]

如何 从 主分支 拉取 指定的文件夹？

- git fetch origin
- git checkout origin/main -- common/

- *这会将远程 `main` 分支下的 `common/` 文件夹同步到你当前的本地目录*



如何 提交 本地的指定文件夹到 主分支

- git checkout main
- git pull origin main 
- git checkout dev -- server/



5. [C++]

    Display* display = XOpenDisplay(nullptr);

如何理解这个类?

- X Server
  - 代表的是管理显卡 鼠标  屏幕的后台进程
- X Client
  - 代表的是 我们写的这个程序
- XOpenDisplay
  - 就像是你的程序和X server 之间拉了一条网线
- Display
  - 代表是 程序和X Server之间的通信渠道
- 这个参数是这样的
  - **传 `192.168.1.10:0`**：代表通过网络连接到另一台电脑的图形界面
  - **`:0.1`**：代表连接到第一个显示服务器的第二个屏幕
  - `:0` 代表“本地机器上的第一个图形界面”



6. [c++]

```c++
Window root = XDefaultRootWindow(display);
```

又如何理解这个类
详细介绍

它的功能 头文件 参数 等

- X11 采用的是句柄模式
  - 真正的窗口对象 放在 X Server的服务器里面
  - 你的后端程序 只有 一个编号
- 在 Linux的图形界面里面
  - Root Window 是树根
  - 等于整个屏幕的分辨率
  - 没有边框 不能移动 也不能被关闭

- ```c++
  #include <X11/Xlib.h>

- ```c++
  Window XDefaultRootWindow(Display *display);
  ```

- display 就是 之前 通过 XOpenDisplay 拿到的这个句柄





7. [C++]

```c++
#include <jpeglib.h>
#include <vector>

std::vector<unsigned char> CompressToJpeg(XImage* image, int quality = 60) {
    std::vector<unsigned char> buffer;
    unsigned char* outbuffer = nullptr;
    unsigned long outsize = 0;

    struct jpeg_compress_struct cinfo;
    struct jpeg_error_mgr jerr;

    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_compress(&cinfo);

    // 关键：压缩到内存而不是文件
    jpeg_mem_dest(&cinfo, &outbuffer, &outsize);

    cinfo.image_width = image->width;
    cinfo.image_height = image->height;
    cinfo.input_components = 3; 
    cinfo.in_color_space = JCS_RGB;

    jpeg_set_defaults(&cinfo);
    jpeg_set_quality(&cinfo, quality, TRUE);
    jpeg_start_compress(&cinfo, TRUE);

    std::vector<unsigned char> row_buffer(image->width * 3);
    while (cinfo.next_scanline < cinfo.image_height) {
        // XImage (BGRA) -> JPEG (RGB) 转换
        unsigned char* line = (unsigned char*)(image->data + cinfo.next_scanline * image->bytes_per_line);
        for (int x = 0; x < image->width; x++) {
            row_buffer[x * 3 + 0] = line[x * 4 + 2]; // R
            row_buffer[x * 3 + 1] = line[x * 4 + 1]; // G
            row_buffer[x * 3 + 2] = line[x * 4 + 0]; // B
        }
        JSAMPROW row_pointer[1] = { row_buffer.data() };
        jpeg_write_scanlines(&cinfo, row_pointer, 1);
    }

    jpeg_finish_compress(&cinfo);
    
    // 将压缩后的数据拷贝到 vector
    buffer.assign(outbuffer, outbuffer + outsize);
    
    // 释放 libjpeg 自动分配的内存
    if (outbuffer) free(outbuffer); 
    jpeg_destroy_compress(&cinfo);

    return buffer;
}
```



- ```c++
  详细介绍一下
  jpeg_compress_struct
  jpeg_error_mgr
  ```

  - jpeg_compress_struct
    - image_width	宽度
    - image_height        高度
    - input_components        通道数
    - in_color_space       输入数据的颜色空间
    - next_scanline       下一行扫描线的索引

  - jpeg_error_mgr   
    - 包含了一系列的函数指针
    - 可以重写这些指针 让 libjpeg 出错的时候 执行指定的逻辑 而不是 退出程序



- jpeg_std_error
  如何理解？

  - ```c++
    struct jpeg_error_mgr * jpeg_std_error (struct jpeg_error_mgr * err);
    ```

  - 填充 默认逻辑

    - 将错误信息打印到 控制台
    - 还有 填充一个 error_exit
      - 打印一个错误信息 然后 释放 libjpeg 占用的内存 然后直接调用 exit 退出程序



- 如何理解 XImage

  - 屏幕像素数据在你的程序内存中的映射

  - 调用 XGetImage 的时候 系统会将显存中的像素点 拉到 你的程序可以访问的内存区域

    - 就是XImage里面

  - 

  - | 字段名                    | 类型            | 理解                                                         |
    | :------------------------ | :-------------- | :----------------------------------------------------------- |
    | **`width`, `height`**     | `int`           | 图像的宽高（像素单位）。                                     |
    | **`data`**                | `char*`         | **最重要的成员**。指向实际像素内存的指针。                   |
    | **`format`**              | `int`           | 通常是 `ZPixmap`。代表像素是按顺序（像素1, 像素2…）排列的。  |
    | **`bits_per_pixel`**      | `int`           | 每个像素占多少位。现代系统通常是 **32**（即 4 字节，BGRA）。 |
    | **`bytes_per_line`**      | `int`           | **关键点**。图像每一行占用的字节数。由于内存对齐，它可能比 `width * 4` 稍微大一点。 |
    | **`red/green/blue_mask`** | `unsigned long` | 告诉你哪几个位代表红色、绿色、蓝色，以此判断颜色顺序（如 RGB 还是 BGR）。 |

  - 销毁 必须得调用 XDestroyImage(image)
  - 







