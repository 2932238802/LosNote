1. [rust]

```rust
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);
```

- 这样子就可以覆盖一个值

- [x] 26_1_7
- [ ] 





2. [rust]

  println!("entry 函数的使用");
    let res = team_to_number.entry(&teams[0]);

如何打印这个res?

```rust
let res1 = team_to_number.entry(&teams[0]);

    match res1{
        Entry::Occupied(number1) =>{
            println!("如果输出的是1 表示a已经有1占有了 {}",number1.get());  // 输出1 表示已经被1占有了
        }
        Entry::Vacant(number2) =>{
            println!("{}",number2.key());
        }
    }

```









3. 

```rust
let teams = vec![String::from("a"),String::from("b"),String::from("c")];

    let numbers = vec![1,2];

    let mut team_to_number:HashMap<_,_> = teams.iter().zip(numbers.iter()).collect();

team_to_number.entry(&String::from("d")).or_insert(&1);
```

"d" 和 ”1“ 本身都不占有 内存 为什么 还是要使用&？



- 因为 team_to_number 定义的时候 就是使用teams和numbers的引用 所以就要用引用哦
- 函数需要什么类型的参数，你就必须给它什么类型的参数
- 既然我们的 HashMap的值类型 V 是 &i32，那么 or_insert 方法就必须接收一个 `&i32` 类型的参数，才能把它存进去

- [ ] 26_1_7



4. 

rust有没有
那种直接初始化哈希表的方式
而不是通过后期一个一个insert

比如 unordered_map<int,int> map{{1,2},{2,3}};



- 

```rust
let map1: HashMap<i32, i32> = [(1, 2), (2, 3), (4, 5)]
.into_iter()
.collect();
```

- 这个 into_iter 可以把数组转换为迭代器
- `collect()` 会消耗掉这个迭代器，并把所有元素收集成一个新的集合 正好看到你想要一个哈希表 巧了



- 

```rust
let map2 = HashMap::from([
(1, 2),
(2, 3),
(4, 5),
]);
```



- 宏

```rust
let map = hashmap!{
"hello" => "world",
"answer" => "42",
"rust" => "awesome"
};

println!("宏创建的 map: {:?}", map);

let map2 = hashmap!{1 => 2, 2 => 3,};
```









5. [rust]

{：？}
如何理解？

- 这个是 #[derive(Debug)] 调试信息打印用的

- [x] 26_1_7





fn main() {
let map: HashMap<&str, i32> = hashmap!{
"a" => 1,
"b" => 2,
};
println!("使用 maplit 包: {:?}", map);
}

那为啥这个不用加 #[derive(Debug)]？

- 都已经在 Rust 的标准库中为你实现了 `Debug` trait

- [x] 26_1_7

















































