1. 

**`SocketAddr`** 类型

- 一个网络套接字 类型

- ::from() 

  - 实现了 From 方法

- ```rust
  let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
  //           └─ 类型      └─ 方法 └───── 元组 ─────┘
  //              ↓
  //         SocketAddr::from( (IP地址, 端口) )
  ```

- [ ] 1_20





---





2. 

```rust
    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();

1. bind的里面的参数是？
2. 为什么 .await后面还可以.unwrap?
```



- 参数 就是 **`addr: SocketAddr`**，
- `.await` **等待 Future 完成**

- [ ] 1_20





---





3. 

```rust
 axum::serve()
这个的参数是？
```

- `axum::serve()` 函数用于启动一个 HTTP 服务器。它接受两个**必需参数**和一个**可选方法**进行扩展
- 第一个参数 tokio::net::TcpListener
- 第二个参数 axum::Router





---





4. 

```
1. static 和 `static的区别？
2.rust这些库是不是都是互相调用的？ 比如这个  axum::serve 必须需要listener 而这个listener又需要tokio::net::TcpListener？
```

- 

凡是带撇号 `'` 的，在 Rust 里都叫**生命周期**。它不是在造变量，而是在描述一个引用的**保质期**。 `'static` 的意思是：**“这个引用指向的数据，保质期是永久。**

- static 全局变量

- Rust 更像是一堆**乐高积木** 是的 你需要这些积木







---





5. [rust]

```rust
async fn search_user(Query(params): Query<SearchParams>) -> String {
    format!("搜索关键词: {}, 页码: {:?}", params.keyword, params.page)
}

如果要作为 get或者post有参函数
必须要用 Query包裹起来对么？
```

- 不对!

- GET /search?keyword=rust&page=1

- 这种 采用 

  -  ```rust 
     async fn handler(Query(params): Query<SearchParams>)
     ```

- 在 http body 里面的 要用 json

  - ```rust
    async fn handler(Json(body): Json<CreateUserRequest>)
    ```

- 如果数据在 URL 路径中间

  - // 路由定义要写成: .route("/users/:id/details", ...)

  - ```rust
    async fn handler(Path(user_id): Path<u32>)
    ```

  - 这种 : 必须要写


- [ ] 1_20























