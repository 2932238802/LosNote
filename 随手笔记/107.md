1. 

```rust
use std::error::Error;
// 1. 引入必要的扩展 Trait (AsyncBufReadExt, AsyncWriteExt)
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use tokio::net::TcpListener;
use tokio::sync::broadcast;

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let listener = TcpListener::bind("127.0.0.1:6379").await?;
    
    // 2. 显式指定泛型 <String>，告诉编译器这个管道传输字符串
    let (tx, _rx) = broadcast::channel::<String>(10);

    println!("聊天室服务端启动: 127.0.0.1:6379");

    loop {
        let (mut socket, addr) = listener.accept().await?;
        println!("新用户加入: {}", addr);

        let tx = tx.clone();
        let mut rx = tx.subscribe();

        tokio::spawn(async move {
            // 3. 把 socket 拆分成 reader 和 writer
            let (reader, mut writer) = socket.split();
            let mut reader = BufReader::new(reader);
            let mut line = String::new();

            loop {
                // 4. 使用 select! 同时监听两个方向
                tokio::select! {
                    // 分支 A: 监听客户端发来的消息
                    result = reader.read_line(&mut line) => {
                        if result.unwrap() == 0 {
                            // 读到 0 字节说明客户端断开了
                            println!("用户离开: {}", addr);
                            break;
                        }

                        print!("收到 {} 的消息: {}", addr, line);
                        let _ = tx.send(line.clone());

                        line.clear();
                    }

  
                    result = rx.recv() => {
                        match result {
                            Ok(msg) => {

                                let _ = writer.write_all(msg.as_bytes()).await;
                            }
                            Err(e) => {
                                println!("广播接收错误: {}", e);
                            }
                        }
                    }
                }
            }
        });
    }
}



```







不是 我的意思是 为什么可以这么写？ 而不是说 对的 该怎么写？ 首先 这个reader.read_line(&mut line) 是 表达式 所以可以被result接受？ 这个是很离谱的地方 另外一个如果是Result作为返回值 那应该 用 match 为啥是拿一个没有声明的变量去接受？ 很奇怪

- [ ] 1_18





- 这其实是 `tokio::select!` 宏自己定义的 **特殊语法 (DSL)**
- **去执行后面那个 Future，等它做完了（await 好了），把返回值赋给前面那个变量名（result），然后执行大括号里的代码**
- `result = ... =>` 这是 `select!` 宏特有的写法

- [ ] 1_18



2. 

```rust
addr 支持被直接打印？
如 ： println!("用户离开: {}",addr);
```



- 对 
- Rust 标准库 已经为它实现了 Display

- [x] 1_19



3. 

```rust
loop {
                tokio::select! {
                    result = reader.read_line(&mut line) =>{
                        if result.unwrap() == 0{
                            println!("用户离开: {}",addr);
                            break;
                        }

                        println!("收到 {} 的信息: {}",addr,line);
                        let _ = tx_sender_clone.send(line.clone());
                    },
                    result = tx_receive.recv() => {
                        match result {
                            Ok(msg) =>{
                                let _ = writer.write_all(msg.as_bytes()).await;
                            }
                            Err(e) =>{
                                println!("广播接受错误: {}",e);
                            }
                        }
                    }
                }
            }

```

我有个问题
如果 `result = ... =>` 这是 `select!` 宏特有的写法
那么 这个 result的类型 必须是 Result对么？



- 不是不是 
- 什么类型都可以 空也可以
- 只是 网络IO 太容易出错





4. 

```rust
let (reader, mut writer) = socket.into_split();
into_split 和 split 的区别是？
```



- split 是借用 
- into_split 是彻底分家 两个完全独立的对象





5. 

```rust
tokio::spawn()
这个括号里面应该要传入什么
```

- 传入一个异步任务

- async move {} 这个最常用

- async {} 这个较少

- ```rust
  async fn do_work() {
      println!("干活！");
  }
  
  // 注意：这里是 do_work()，也就是把函数运行产生的 Future 传进去
  tokio::spawn(do_work());
  ```

























