1. 

let msg = String::from("Hello Redis");

// 变成了 &[u8] 切片，没有发生内存复制，非常快
let bytes = msg.as_bytes(); 

// 发送出去
socket.write_all(bytes).await?;

 

最后都 write_all 
难道也没有发生 内存复制么？


- 在 `write_all` 内部：发生了复制 (系统调用)

  当你调用 `socket.write_all(bytes).await` 时，底层发生的事情是：

  - Rust 调用了操作系统的 `write` (Linux) 或 `send` (Windows) **系统调用 (Syscall)**。
  - **关键点**：操作系统内核为了安全和稳定性，**必须**把你的数据从你的**用户空间内存** 拷贝到 **内核空间的发送缓冲区**

- [x] 1_19




2. [rust]

```rust
let parts: Vec<&str> = ...; // 这是一个字符串向量，比如 ["SET", "a", "1"]

// parts.as_slice() 把它变成了切片 &[&str]
match parts.as_slice() {
    
    // 模式 1: 刚好有3个元素，且第一个必须是 "SET"
    ["SET", key, value] => { 
        // 这里的 key 自动绑定到 "a"
        // 这里的 value 自动绑定到 "1"
        // 只有结构和内容都对上了，才进这里
    },

    // 模式 2: 刚好有2个元素，且第一个必须是 "GET"
    ["GET", key] => {
        // key 绑定到第二个元素
    },

    // 模式 3: _ 代表“其他所有情况”（比如长度不对，或者命令不对）
    _ => { ... }
}

```

如何理解 整个 as_slice
以及 match 为啥可以用在这里？

- Vec<&str> 就是在堆上 存了一堆的胖指针
- **`parts.as_slice()`**  返回的是 **切片引用**



只要是 切片 都可以被match是这个意思么？

- 是的 只要是 切片都可以 被 match





3. [rust]

&str这个才是切片啊
为啥 这个也是 &[&str]?



- &str 这个是字符串 切片

- `&[...]`：这是**容器的切片**

-  

  它只存一个东西：**内存地址**。

  - `&i32`：指向一个整数的地址。
  - `&String`：指向一个 String 结构体的地址。
    - 注意：`&String` **不是** 切片！它只是指向那个 String 对象本身的指针。

   2. 切片引用 (Fat Pointer / 胖指针)

  它存两个东西：**内存地址** + **长度**。 因为不知道长度的话，不知道这块肉切到了哪里。

  - `&[u8]`：指向一串字节，并且知道有几个。
  - `&str`：指向一串 UTF-8 字符，并且知道有多长。





let parts: Vec<&str> = ...; // 这是一个字符串向量，比如 ["SET", "a", "1"]

// parts.as_slice() 把它变成了切片 &[&str]
match parts.as_slice() 

这个 parts 的所有权是不是没了



- 没有 只是借用

- **当不可变引用（借用）存在时，原变量绝对不允许被修改**

- ```rust
  let mut parts = vec!["SET", "key"];
  
  // 1. 开始借用
  let slice = parts.as_slice(); 
  
  // 2. 试图修改原变量 —— 危险操作！
  parts.push("value"); 
  // ❌ 砰！编译报错！
  ```







4. 

```rust
let db:Arc<Mutex<HashMap<String,String>>> = Arc::new(Mutex::new(HashMap::new()));
let db_clone = db.clone();
let data = db_clone.lock().unwrap();

这个 lock().unwrap()
难道既发挥了 lock_guard的作用 也发挥了 把锁打开了么？
```



- db_clone 是抢锁
- Arc 是保证了 只要 有一个人 拿着 这块内存就不会被释放 这个房子就不会被拆迁
- 但是 Mutux 是 互斥访问的
- 同一时间 只能有一个 人 进厕所上厕所
- MutexGuard 是主角 也就是这里的 data
  - 它是凭证 只要它 存在 别人就进不来
  - 它是钥匙 可以直接操作里面的 HashMap
  - 自动门 离开作用域的 时候 自动销毁 自动把锁 打开



5. 

```rust
match client_format.as_slice() {

                    ["SET",key,value] =>{
                        let data: std::sync::MutexGuard<'_, HashMap<String, String>> = db_clone.lock().unwrap();
                        data.insert(key.to_string(), value.to_string());
                    },
                    ["GET",key] => {
                        let data = db_clone.lock().unwrap();
                        let value = match data.get(key) {
                            Some(val) => val,
                            _ => ""
                        };
                    },


                }

这里 为什么 key要 加*
如何理解*？
```



- 这是因为 Rust 的 **“匹配工效学” (Match Ergonomics)** 机制。

1. `client_format.as_slice()` 返回的是一个 **引用**：`&[&str]`。
2. 当你 `match` 一个引用时，Rust 为了方便你（不让你移动所有权），会自动把里面的变量也绑定为引用。
3. 原本里面的元素是 `&str`，现在又给它加了一层引用，就变成了 **`&&str`**



- use std::process::exit;
  - 这里里面有退出













