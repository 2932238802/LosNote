1. 

```rust
pub fn create_json(user_id : &str , role : u8) -> anyhow::Result<String>{

    let now: SystemTime = SystemTime::now();
    let since_epoch = now.duration_since(UNIX_EPOCH)?;

    let two_day: usize = 24 * 60 * 2 * 60 ;
    let all_exp  = two_day + since_epoch.as_secs();

    let new_claims: Cliams = Cliams { 
        sub: user_id.to_owned(), 
        exp: all_exp, 
        iat: since_epoch.as_secs() as usize, 
        role: role
    };

    let jwt_key = std::env::var("JWT_KEY").unwrap();
    let key = EncodingKey::from_secret(jwt_key.as_bytes());
    
    let token = encode(
        &Header::default(), 
        &claims, 
        &key)?;

    Ok(token)
}

为什么 
anyhow::Result<String>
和 Ok(token)

可以匹配上？
```



- anyhow::Result<String>
  - 本质就是 std::result::Result<String, anyhow::Error>
- **`token`** 是通过 `?` 提取出来的 **`String`**。
- **`Ok(token)`** 将这个 `String` 包装成函数要求的 **`Result` 成功分支**。
- **`anyhow::Result<String>`** 允许函数在成功时返回 `String`。
- 两者在类型声明上完全一致，所以编译通过





2. 

```rust
let user_record = sqlx::query("SELECT id, password, name, avatar FROM users WHERE username = ?1")
    .bind(&request.username)
    .fetch_optional(pool)
    .await.map_err(|_|{
        500 as u16
    })?;


如何理解 这个 fetch_optional？
```

- `fetch_optional` 是一个非常关键的操作。简单来说，它的含义是：**“去查一下，有就给我（Some），没有也别报错（None）**

- **`fetch_all`**: 期待返回 **0 到多个** 记录。返回 `Result<Vec<T>, Error>`。
- **`fetch_one`**: 期待返回 **刚好 1 个** 记录。如果没有查到，它会**直接报错**（返回 `Err(RowNotFound)`）



3. 

```rust
use lettre::transport::smtp::authentication::Credentials;
use lettre::{Message, AsyncSmtpTransport, AsyncTransport, Tokio1Executor};
use anyhow::Context;

pub async fn send_verification_code(to_email: &str, code: &str) -> anyhow::Result<()> {
    // 1. 配置邮件内容
    let email = Message::builder()
        .from("LosGate官方 <your_email@163.com>".parse()?)
        .to(to_email.parse()?)
        .subject("【LosGate】您的注册验证码")
        .body(format!("您好！您的验证码是：{}。有效期为5分钟，请勿泄露给他人。", code))
        .context("创建邮件消息失败")?;

    // 2. 配置 SMTP 服务器 (以163为例)
    // 注意：这里的密码通常是邮箱设置里开启 SMTP 后给的“授权码”
    let smtp_user = "your_email@163.com";
    let smtp_pass = "YOUR_AUTH_CODE"; 
    let smtp_host = "smtp.163.com";

    let creds = Credentials::new(smtp_user.to_string(), smtp_pass.to_string());

    // 3. 创建异步传输对象
    let mailer: AsyncSmtpTransport<Tokio1Executor> =
        AsyncSmtpTransport::<Tokio1Executor>::relay(smtp_host)?
            .credentials(creds)
            .build();

    // 4. 发送邮件
    mailer.send(email).await.context("邮件发送失败")?;

    Ok(())
}
```

- 发送邮件的常规逻辑

- [ ] 26_1_26





4. 

```rust
use lettre::transport::smtp::authentication::Credentials;
use lettre::Message;
use lettre::AsyncSmtpTransport;
use lettre::Tokio1Executor;

这几个的作用是？
```

-  Message 是定义邮件的内容
-  Credentials 是身份认证
   -  **身份认证**（证明你有权通过这个邮箱发信)
-  AsyncSmtpTransport 是快递卡车
   -  它是真正负责连接邮件服务器（如 `smtp.163.com`）并把数据发出去的引擎
-  `Tokio1Executor`  卡车司机
   -  `lettre` 这个库支持多种异步引擎（比如 async-std, tokio）。`Tokio1Executor` 明确告诉 `lettre`：“请使用 **Tokio 1.x** 的线程池来处理我的异步任务”



5. 

```dockerfile
# --- 第一阶段：编译 ---
FROM rust:1.75-slim-bookworm AS builder
WORKDIR /app
# 安装编译所需的依赖（针对 Sqlite）
RUN apt-get update && apt-get install -y pkg-config libssl-dev && rm -rf /var/lib/apt/lists/*

COPY . .
# 编译为 Release
RUN cargo build --release

# --- 第二阶段：运行 ---
FROM debian:bookworm-slim
WORKDIR /app
# 安装运行时必要的库
RUN apt-get update && apt-get install -y libssl3 ca-certificates && rm -rf /var/lib/apt/lists/*

# 从编译阶段拷贝二进制文件
COPY --from=builder /app/target/release/los_gate /app/los_gate

# 暴露端口
EXPOSE 3000

CMD ["./los_gate"]

```

dockerfile 进行学习:

- 先 是 更新 apt-get update
- 然后 `apt-get install -y pkg-config libssl-dev`
  - 一个是 pkg-config 是crate 必备的包
  - 然后 libssl-dev 是 OpenSSL 的 开发库

- /var/lib/apt/lists/*
  - 是删除软件包 产生的软件包索引文件



​	













