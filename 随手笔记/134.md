1. 

0:start:6
这种字符串 如何 分割出 0 start 还有 6？



- ```c++
  #include <iostream>
  #include <string>
  #include <vector>
  
  int main() {
      std::string s = "0:start:6";
      size_t pos = 0;
      size_t lastPos = 0;
      std::vector<std::string> res;
  
      while ((pos = s.find(':', lastPos)) != std::string::npos) {
          res.push_back(s.substr(lastPos, pos - lastPos));
          lastPos = pos + 1;
      }
      res.push_back(s.substr(lastPos)); // 别忘了最后一部分
  
      return 0;
  }
  
  ```

- [x] 26_1_28





2. 

C++右值解决了什么问题，如何进行分辨左值还是右值

- 避免了 临时对象 在拷贝中的巨大开销
- 取地址进行分辨

- [x] 26_1_28
- [x] 26_2_3





3. [c++]

emplace_back 在底层都做了什么

它直接在 vector 管理的内存末尾，调用构造函数**就地构造**元素，省去了先构造临时对象再拷贝/移动的步骤

- [x] 26_1_28
- [x] 26_2_3



4. [C++]

vector的 内存扩展的时候 到底是将原来的元素进行拷贝还是移动取决于什么

`vector` 在扩容时会根据元素的**移动构造函数是否有 `noexcept` 声明**来决定。如果有，则为了性能执行移动语义；如果没有，则为了保证**强异常安全**，防止扩容失败导致原数据损坏，会回退到拷贝语义。这在底层是通过 `std::move_if_noexcept` 来实现的

- [x] 26_1_28



**为自定义类的移动构造函数加上 `noexcept` 极其重要**

- [x] 26_1_29





5. [C++]

什么是 强异常安全保证？

即操作如果失败，程序的状态必须回滚到操作开始之前的样子

- [x] 26_1_28



移动构造函数

```c++
#include <iostream>
#include <vector>

class MyBuffer {
public:
    int* data;
    size_t size;

    MyBuffer(size_t s) : size(s) {
        data = new int[s];
        std::cout << "申请内存\n";
    }

    // 1. 拷贝构造函数：深拷贝（慢）
    MyBuffer(const MyBuffer& other) : size(other.size) {
        data = new int[size];
        for (size_t i = 0; i < size; ++i) data[i] = other.data[i];
        std::cout << "深拷贝内存\n";
    }

    // 2. 移动构造函数：资源转移（快！）
    MyBuffer(MyBuffer&& other) noexcept : data(other.data), size(other.size) {
        // 核心：把对方指向内存的指针置空，防止对方析构时把内存释放掉
        other.data = nullptr;
        other.size = 0;
        std::cout << "移动资源\n";
    }

    ~MyBuffer() {
        delete[] data;
    }
};
                                                                 
```

