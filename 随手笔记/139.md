1. 

C++

- **第一步：获取对象首地址** 当你有一个指向对象的指针（如 `Base* ptr`），`ptr` 的值就是对象的内存起始地址。

- **第二步：取出虚指针 (vptr)** 在大多数编译器实现中（如 GCC、Clang、MSVC），如果类有虚函数，编译器会将一个隐藏的指针——**vptr（虚表指针）** 放在对象内存布局的**最前面**（即偏移量为 0 的位置）。

- *代码逻辑*：`*(void**)ptr` 就能拿到 vptr 的值。

- **第三步：跳转到虚表 (vtable)** vptr 的值就是虚函数表在内存中的**起始地址**。

- **第四步：通过索引找到函数地址** 虚函数在表中的位置是编译时就确定的（按声明顺序排列）。

- *代码逻辑*：`vtable[index]` 得到对应的虚函数机器码地址

- [ ] 26_1_28



它存储在 **全局/静态存储区** 中的 **只读数据段 (.rodata 或 .text)**

- [x] 26_1_28
- [ ] 



```tex
[ 内存高地址 ]
-------------------
|   栈 (Stack)    |  <- 局部变量
-------------------
|        |        |
|   堆 (Heap)     |  <- new 出来的对象 (里面包含 vptr)
-------------------
| 全局/静态存储区  |
|  (.data / .bss) |
-------------------
| 只读数据段      |  <-- 虚函数表 (vtable) 存储在这里！
|  (.rodata)      |  <-- 字符串常量也在这里
-------------------
| 代码段 (.text)  |  <-- 虚函数的机器码指令
-------------------
[ 内存低地址 ]
```

- [ ] 26_1_28



多重继承下 会有多个列表





2. 

编译器怎么知道一个类有咩有虚表指针？
难道不管这个类有没有虚函数 都会取出内存中的前面几个字节么？

- 编译器 编译的时候 就会做了这个工作
- 当编译器 解析一个类的声明的时候 如果发现这个类 写了virtual 关键字
- 或者这个类 里面有 virtual 关键字
- 就会打上标记 ， 标记为 多态的类

- [x] 26_1_28





3. 

```c++
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        quicksort(nums, 0, nums.size() - 1);
        return nums;
    }

    void quicksort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        int pivot = nums[left + (right - left) / 2];
        int i = left - 1;
        int j = right + 1;
        while (i < j) {
            do { i++; } while (nums[i] < pivot);
            do { j--; } while (nums[j] > pivot);
            if (i < j) swap(nums[i], nums[j]);
        }
        quicksort(nums, left, j);
        quicksort(nums, j + 1, right);
    }
};

```

- 快排的逻辑

- [ ] 26_1_28



4. 

快排的复杂度范围





优化的方案

三数取中

```c++
void quickSort(vector<int>& nums, int left, int right) {
    if (left >= right) return;

    // 1. 三数取中逻辑
    int mid = left + (right - left) / 2;
    
    // 排序这三个数，使得 nums[left] <= nums[mid] <= nums[right]
    if (nums[left] > nums[mid]) swap(nums[left], nums[mid]);
    if (nums[left] > nums[right]) swap(nums[left], nums[right]);
    if (nums[mid] > nums[right]) swap(nums[mid], nums[right]);

    // 此时，nums[mid] 绝对是这三个数里的中位数
    int base = nums[mid]; 

    // 2. 后续的分区逻辑 (Hoare Partition)
    int i = left - 1, j = right + 1;
    while (i < j) {
        do { i++; } while (nums[i] < base);
        do { j--; } while (nums[j] > base);
        if (i < j) swap(nums[i], nums[j]);
    }
    
    quickSort(nums, left, j);
    quickSort(nums, j + 1, right);
}

```

- [ ] 26_1_29








