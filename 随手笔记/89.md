1. 

	void drawBasePoint(QPointF pos);

这个传 const 引用好一点 还是直接这么传好一点



传值 (QPointF pos)：编译器通常会将这两个 double 值直接放入 CPU 的 寄存器 (Registers) 中传递。CPU 访问寄存器的速度极快。
传引用 (const QPointF &pos)：必须把地址放入寄存器，CPU 使用时需要去内存里读取数据。这不仅慢，还可能因为缓存未命中 (Cache Miss) 导致性能损耗



- [ ] 26_1_7



2. 

详细介绍一下QGraphics 族之间的关系

QGraphicsScene

- 所有图元的容器和管理器

QGraphicsView

- 窗口 相机 
- 缩放旋转和平移
- 一个scene 可以被 多个 view 观察
- 将scene 内容渲染到屏幕上

QGraphicsItem

- 具体对象
- paint() 绘制自己
- boundingRect() 定义自己的区域

Scene（场景） = 剧本/舞台世界（定义了谁在哪里，发生了什么）。
View（视图） = 摄像机/电视屏幕（观众通过它看到舞台的一部分，可以放大缩小）。
Item（图元） = 演员/道具（在舞台上表演的具体物体）

包含关系：QGraphicsScene 包含 QGraphicsItem（通过 scene->addItem(item)）。
观察关系：QGraphicsView 关联 QGraphicsScene（通过 view->setScene(scene)）。
父子关系：QGraphicsItem 可以有父 Item（通过 item->setParentItem(parent)），形成树状结构


QGraphicsLineItem：线段。
QGraphicsRectItem：矩形。
QGraphicsEllipseItem：椭圆/圆。
QGraphicsPathItem：任意路径（非常强大，用于复杂形状）。
QGraphicsPolygonItem：多边形。
QGraphicsTextItem：简单的文本。
QGraphicsPixmapItem：显示位图（图片）


QGraphicsObject：
继承自 QGraphicsItem 和 QObject。
用途：当你需要图元发射信号（如 clicked）或使用属性动画（QPropertyAnimation）时，必须继承此类，而不是直接继承 QGraphicsItem





3. 

如何理解 qApp?



- 是一个全局的宏

- setFont 是设置字体
- setStyleSheet() 设置全局样式
- 设置应用程序的主要图标
- clipboard 获取系统剪切板
- 退出应用程序 qApp->quit()





4. 

```shell
PS D:\LosAngelous\rustProject\cargo_test> cargo build
   Compiling cargo_test v0.1.0 (D:\LosAngelous\rustProject\cargo_test)
error[E0308]: mismatched types
  --> src\main.rs:54:21
   |
54 |     print!("{}",map[field_name]);
   |                     ^^^^^^^^^^ expected `&_`, found `String`
   |
   = note: expected reference `&_`
                 found struct `String`
help: consider borrowing here
   |
54 |     print!("{}",map[&field_name]);
   |                     +

For more information about this error, try `rustc --explain E0308`.
error: could not compile `cargo_test` (bin "cargo_test") due to 1 previous error
PS D:\LosAngelous\rustProject\cargo_test>


```

```rust
fn main(){
    use std::collections::HashMap;
let field_name = String::from("hello");
let field_out = String::from("world");

let mut map = HashMap::new();
map.insert(field_name,field_out);

print!("{}",map[field_name]);
}
```



报错原因：

- field_name 和 field_out 被map拿走了 
- 所以打印会报错

- [ ] 26_1_26



```rust
fn main(){
    use std::collections::HashMap;

    let field_name = String::from("hello");
    let field_out = String::from("world");

    let mut map = HashMap::new();
    map.insert(field_name.clone(),field_out);

    print!("{}",map[field_name]);
}
```

还是会报错

- 因为 field_name 需要加上引用 不然所有权就没有了 



```rust
fn main(){
     use std::collections::HashMap;

     let field_name = String::from("hello");
     let field_out = String::from("world");

    let mut map = HashMap::new();
    map.insert(field_name.clone(),field_out);

  print!("{}",map[&field_name]);
}
```





5. 

```rust
fn main(){

    let teams = vec![String::from("a"),String::from("b"),String::from("c")];

    let numbers = vec![1,2,3,4];

    let team_to_number = teams.iter().zip(numbers.iter()).collect();

    print!("{}",team_to_number[&teams[0]]);
}
```

报错

- 报错的原因是 要明确告诉编辑器 你需要 收集到怎么样的容器

更正↓

```rust
fn main(){

    let teams = vec![String::from("a"),String::from("b"),String::from("c")];

    let numbers = vec![1,2,3,4];

    let team_to_number:HashMap<_,_> = teams.iter().zip(numbers.iter()).collect();

    print!("{}",team_to_number[&teams[0]]);
}
```

即可



























