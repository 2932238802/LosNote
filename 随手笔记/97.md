1.  [rsut]

- 所有存储在 Stack的数据  固定大小
- heap 的话  分配空间 需要做更多的工作

- [x] 1_17
- [ ] 



2. 

```rust
fn get_str_number(str_2:String) -> (String,usize){
    let lenth = str_2.len();
    (str_2,lenth)
}

fn main(){

    let mut str_1 : String = String::from("hello wolrd");
    let mut (str_2,str_2_lenth) : (String,usize)  = get_str_number(str_1);

    print!("{}",str_1);
}
```

- str_1 的所有权没有了

- [x] 1_16

- [ ] 1_17



3. [c++]

引用和指针的区别？

- 指针可以理解为 写着 地址的纸条 想要找到对应的房子 必须解引用
- 引用 就是 一个人的外号 这个外号一定会被初始化 
- 指针可以不被 初始化
- 在概念上 引用不是一个对象 它没有自己的内存地址
- 指针 是一个 独立的对象 它占用内存空间 当你对指针取地址的时候得到的是指针本身的地址

- [x] 1_17



4. [rust]

- 引用作为函数参数的行为 叫做 “借用”



5. 

字符串切片 本质 是一个指针+指针长度么 
和 string_view 一样嘛？



- | 特性         | Rust `&str`                  | C++ `std::string_view`               |
  | :----------- | :--------------------------- | :----------------------------------- |
  | **底层结构** | `ptr` (指针) + `len` (长度)  | `ptr` (指针) + `len` (长度)          |
  | **所有权**   | 不拥有数据（借用）           | 不拥有数据（非拥有式视图）           |
  | **拷贝开销** | 极低（只拷贝两个数字）       | 极低（只拷贝两个数字）               |
  | **修改数据** | 不可变（默认）               | 不可变（只读视图）                   |
  | **生命周期** | 编译器严格检查，防止悬垂引用 | 需要程序员自己小心，容易出现悬垂引用 |
  | **空结尾**   | 不保证以 `\0` 结尾           | 不保证以 `\0` 结尾                   |



- [ ] 1_17















