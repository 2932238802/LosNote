1. [c++]

XGetImage
如何理解？



- ```c++
  XImage *XGetImage(
      Display *display,      // 连接句柄
      Drawable d,            // 抓取目标（你的项目里是 root 窗口）
      int x, int y,          // 起始坐标（左上角）
      unsigned int width,    // 抓取宽度
      unsigned int height,   // 抓取高度
      unsigned long plane_mask, // 位面掩码（通常设为 AllPlanes 或 ~0）
      int format             // 图像格式（通常设为 ZPixmap）
  );
  ```

- 把指定一个 Drawable 的像素数据 拷贝到程序当中



2. [c++]

- jpeg_mem_dest

  - ```c++
    void jpeg_mem_dest(
        j_compress_ptr cinfo,          // 压缩器结构体指针
        unsigned char ** outbuffer,    // [重要] 指向“缓冲区指针”的指针
        unsigned long * outsize        // [重要] 指向“大小变量”的指针
    );
    ```

- 把压缩好的 jpeg 直接 写到内存缓存区里面去 RAM

- 双指针 对于 扩容的意义

  - ```tex
    假设你用单指针传递：void func(unsigned char* p)。
    
    当你调用 func(my_ptr) 时，函数内部的 p 只是 my_ptr 的一个副本（值传递）。
    
    如果在函数内部发生了 realloc（扩容），内存地址从 0x1000 变到了 0x2000。
    
    函数内部的 p 变成了 0x2000，但函数外部的 my_ptr 依然是 0x1000。
    
    结果：函数结束后，外部的 my_ptr 指向了一块已经被释放的非法内存（野指针）
    ```

  - 所以 之所以 双指针 可以实现扩容就是因为
    可以改变 原来 内存区域的指针指向(该区域较小)
    然后 指向一个内存更大的区域对么
  - 对的



3. 

```c++
jpeg_set_defaults
如何理解？
```

- 就是 根据 你已经设置好的图像基本信息 
- 自动把剩下的几百个复杂的压缩参数填充为 工业标准的 默认值



4. 

jpeg_set_quality()

- ```te
  int quality (0 - 100)
  这是你最关心的数字：
  
  100：最高质量。几乎没有视觉损耗，但文件非常大。注意：即使是 100 也是有损压缩，只是损耗极小。
  
  80 - 90：高质量。通常用于摄影作品，肉眼几乎看不出区别。
  
  50 - 70 (远程控制建议值)：中等质量。你会开始看到一些微小的噪点（马赛克），但文件体积会缩减到原来的 1/10 甚至更小。对于 30 FPS 的远程桌面，这是性能最平衡的区间。
  
  10 - 30：低质量。画面会出现明显的“方块效应”（马赛克严重），但在网络极差的情况下，它可以保证画面不卡顿

- #### **`force_baseline`**

  - 这个表示 按照基准标准 









5. 

```c++
#include "LosJpeg.h"

LosJpeg::LosJpeg()
{
    LOS_compress.err = jpeg_std_error(&LOS_errorMgr);
    jpeg_create_compress(&LOS_compress);
}

LosJpeg::~LosJpeg(){
    jpeg_destroy_compress(&LOS_compress);
}

/**
26_2_15
- 压缩 图片
*/
std::vector<unsigned char> LosJpeg::compressXimage(XImage* image, int quality){

    if(nullptr == image || nullptr == image->data) {
        return {};
    }

    // 1. 设置内存目的地
    unsigned char* outbuffer = nullptr;
    unsigned long outsize = 0;
    // libjpeg 会动态分配 outbuffer 的内存，outsize 会存入最终压缩后的大小
    jpeg_mem_dest(&LOS_compress, &outbuffer, &outsize);

    // 2. 配置图像属性
    LOS_compress.image_width = image->width;    // 宽度
    LOS_compress.image_height = image->height;  // 高度
    LOS_compress.input_components = 3;          // RGB 三通道
    LOS_compress.in_color_space = JCS_RGB;      // 输入颜色空间为 RGB

    jpeg_set_defaults(&LOS_compress);
    jpeg_set_quality(&LOS_compress, quality, TRUE);

    // 3. 开始压缩周期
    jpeg_start_compress(&LOS_compress, TRUE);

    // 4. 逐行转换并写入数据
    // libjpeg 期望 RGB (3字节)，而 XImage 通常是 BGRA (4字节)
    int row_stride = image->width * 3;
    std::vector<unsigned char> row_buffer(row_stride);

    while (LOS_compress.next_scanline < LOS_compress.image_height) {
        // 计算 XImage 当前行的起始指针
        // 注意：必须使用 bytes_per_line 处理内存对齐
        unsigned char* x_row_ptr = reinterpret_cast<unsigned char*>(
            image->data + (LOS_compress.next_scanline * image->bytes_per_line)
        );

        // 手动进行颜色转换：BGRA -> RGB
        for (int x = 0; x < image->width; ++x) {
            // XImage 数据通常是 B, G, R, A 顺序
            row_buffer[x * 3 + 0] = x_row_ptr[x * 4 + 2]; // R
            row_buffer[x * 3 + 1] = x_row_ptr[x * 4 + 1]; // G
            row_buffer[x * 3 + 2] = x_row_ptr[x * 4 + 0]; // B
        }

        // 写入这一行数据包
        JSAMPROW row_pointer[1] = { row_buffer.data() };
        jpeg_write_scanlines(&LOS_compress, row_pointer, 1);
    }

    // 5. 完成压缩，此时 outbuffer 已经填满了 JPEG 数据
    jpeg_finish_compress(&LOS_compress);

    // 6. 拷贝到结果 vector
    std::vector<unsigned char> result(outbuffer, outbuffer + outsize);

    // 7. 【重要】释放 libjpeg 自动分配的临时缓冲区
    if (outbuffer) {
        free(outbuffer);
    }

    return result;
}

```

- 图像压缩代码

- ```c++
  void jpeg_start_compress (
      j_compress_ptr cinfo, 
      boolean write_all_tables
  );
  ```

  - write_all_tables 它表示把所有的编码表都写进数据包

- 严格的顺序

  - ```c++
    jpeg_create_compress (创建)
    
    设置参数 (宽高、颜色等)
    
    jpeg_set_defaults (设为默认)
    
    jpeg_start_compress (启动！进入写入阶段)
    
    jpeg_write_scanlines (循环写入像素行)
    
    jpeg_finish_compress
    ```

- XImage 是 4 个字节 顺序是 B G R A

- 目的地是 JPEG 3 R G B



