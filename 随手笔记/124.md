1. 

```rust
use lettre::transport::smtp::authentication::Credentials;
use lettre::{Message, AsyncSmtpTransport, AsyncTransport, Tokio1Executor};

pub async fn send_verification_code(target_email: &str, code: &str) -> Result<(), String> {
    // 1. 配置 163 邮箱凭据
    let smtp_server = "smtp.163.com";
    let username = "你的163邮箱@163.com"; 
    let password = "你的16位授权码"; // 不是登录密码！

    // 2. 创建邮件内容
    let email = Message::builder()
        .from(username.parse().unwrap())
        .to(target_email.parse().unwrap())
        .subject("【Lostrans】您的注册验证码")
        .body(format!("您好！您的验证码是：{}。有效期为5分钟，请尽快完成注册。", code))
        .map_err(|e| e.to_string())?;

    // 3. 配置 SMTP 传输
    let creds = Credentials::new(username.to_string(), password.to_string());
    
    // 使用 465 端口 (SSL) 或 587 端口 (TLS)
    let mailer = AsyncSmtpTransport::<Tokio1Executor>::relay(smtp_server)
        .unwrap()
        .credentials(creds)
        .build();

    // 4. 发送邮件
    match mailer.send(email).await {
        Ok(_) => Ok(()),
        Err(e) => Err(format!("邮件发送失败: {:?}", e)),
    }
}
```

1. 如何理解 Credentials::new？
2. 如何理解 parse
3. 如何理解  AsyncSmtpTransport::<Tokio1Executor>::relay？
4. 选择 465 还是 587 怎么看？  函数改哪里
5. mailer.send 参数类型是？



- `parse()` 类型转换器

- `AsyncSmtpTransport::<Tokio1Executor>::relay`？

  这是最显眼的一行，我们拆成三部分看：

  - **`relay("smtp.163.com")`**：这叫“中继”。意思是你不是直接把邮件发给对方，而是先把邮件交给 163 的服务器，让它帮你转发出去。
  - **`<Tokio1Executor>`**：这叫“涡轮鱼 (Turbofish)”语法。
    - Rust 有很多异步框架（Tokio, async-std 等）。
    - `lettre` 库为了通用性，它不知道你用的是哪个框架。
    - 通过这行代码，你明确告诉它：“**请使用 Tokio 1.x 版本的执行器来跑这个异步任务**”。
  - **`AsyncSmtpTransport`**：表示这是一个“异步的 SMTP 传输通道”
  
- **465 (SMTPS)**：一上来就建立加密连接（SSL/TLS）。**163 邮箱和 QQ 邮箱通常推荐这个，非常稳定。**

- **587 (STARTTLS)**：先建立普通连接，再升级为加密连接

- ```rust
  let mailer = AsyncSmtpTransport::<Tokio1Executor>::wrapper_config(
      smtp_server, 
      465, // 手动指定端口
      true // 使用 TLS
  )
  .credentials(creds)
  .build();
  
  // 如果选 587
  let mailer = AsyncSmtpTransport::<Tokio1Executor>::relay(smtp_server)
      .unwrap()
      .port(587) // 这样改端口
      .credentials(creds)
      .build();
  ```

- mailer.send的类型 是 Message





2. 

use redis::AsyncCommands; 

- 这个才能异步





3. [rust]

use dotenvy::dotenv;
dotenv().ok();

作用是什么



- 运行到 dotenv().ok() 
  - 程序回去寻找 根目录 下的 .env 文件
  - 加载之后 可以 通过 std::env::var来读取 文件信息



4. 

















