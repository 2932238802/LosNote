1. 
   priority_queue
   详细介绍一下

- ```c++
  template<
      class T,
      class Container = std::vector<T>,
      class Compare = std::less<typename Container::value_type>
  > class priority_queue;
  ```

- [ ] 26_1_30



- **T**：数据类型（如 `int`, `double`, `MyStruct`）。
- **Container**：底层存储容器。必须是支持随机访问的容器，默认是 `std::vector`（也可以用 `std::deque`，但 `vector` 效率更高）。
- **Compare**：比较规则。
  - `std::less<T>`（默认）：**大顶堆**（大的先出）。
  - `std::greater<T>`：**小顶堆**（小的先出）

- [ ] 26_1_30





2. 

```c++
std::priority_queue<int> pq1; 
```

- 大顶堆

- [ ] 26_1_30



```c++
int main() {
  std::priority_queue<int> p1;

  p1.push(3);
  p1.push(1);
  p1.push(2);

  std::cout << p1.top() << std::endl;
  // 默认 从大到小
}
```

- 默认是大堆

- [ ] 26_1_30



如何 打印 priority_queue?

```c++
#include <functional>
#include <iostream>
#include <queue>

template <class T, class contain, class Compare>
class MyPri : public std::priority_queue<T, contain, Compare> {
public:
  void Print() {
    for (auto a : this->c) {
      std::cout << a << " ";
    }
  }
};

int main() {
  MyPri<int, std::vector<int>, std::greater<int>> my_pri;
  my_pri.push(1);
  my_pri.push(4);
  my_pri.push(3);
  my_pri.push(2);
  my_pri.Print();
}

现在树的结构长什么样
```

- 只能这样的 访问底层的 vector

- ```tex
        1
       / \
      4   3
    
  ```

- ```tex
        1
       / \
      4   3
     /
    2  <-- 新加入的
  ```

- ```tex
        1
       / \
      2   3
     /
    4 
  ```

- [ ] 26_1_30





3. 

```tex
152. 乘积最大子数组
     已解答
     中等
     相关标签
     premium lock icon
     相关企业
     给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。
请注意，一个只包含一个元素的数组的乘积是这个元素的值。
示例 1:

输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

这个我这种做法 是不是 太慢了
有没有更好的办法？
```

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int size_ = nums.size();
        int max_ = nums[0];
        for(int i = 0 ; i < size_ ; i++)
        {
            int  temp = 1;
            for(int j = i; j < size_ ; j++)
            {
                // 下一位
                temp = temp * nums[j];
                max_ = max(max_ , temp);
            }
        }
        return max_;
    }
};

```


=======
```shell
cmake .. -DCMAKE_TOOLCHAIN_FILE="E:/vcpkg/scripts/buildsystems/vcpkg.cmake" -DCMAKE_BUILD_TYPE=Release
这个指令可以直接通过
set(DCMAKE_TOOLCHAIN_FILE,"") 这样么？
```

- 不支持

- 推荐:

  - ```shell
    cmake .. -DCMAKE_TOOLCHAIN_FILE=E:/vcpkg/vcpkg/scripts/buildsystems/vcpkg.cmake
    ```



2. [C++]

QByteArray 的填充方式

- ```c++
  QByteArray ba1(10, 'A'); 
  ```

  - 填充 指定个数的 字符

- ```c++
  QByteArray ba4(10, Qt::Uninitialized); 
  ```

  - 十个 字节 但是不初始化

- ```c++
  const char* str = "Hello";
  QByteArray ba1(str);  
  ```

- ```c++
  QByteArray ba2("World");  
  ```

  - C语言的初始化方式

- ```c++
  const char data[] = { 'H', 'i', '\0', '!' };
  QByteArray ba3(data, 4);
  QByteArray ba4(data, 2); 
  ```

  - 加长度 构造

- 

  ```c++
  QByteArray ba2 = QByteArray::fromRawData("Raw", 3);  // 不拷贝数据
  QByteArray ba3 = QByteArray::fromHex("48656c6c6f");  // 从十六进制字符串
  QByteArray ba4 = QByteArray::fromBase64("SGVsbG8="); // 从Base64
  QByteArray ba5 = QByteArray::fromPercentEncoding("Hello%20World%21"); 
  ```



3. [c++] [protobuf]

```c++
bool Message::ParseFromArray(const void* data, int size);
```

- **输入**：二进制数据指针和数据大小
- **输出**：`bool`，表示解析是否成功
- **作用**：将二进制数据填充到当前消息对象中

- [ ] 26_2_3
>>>>>>> 2d7e01c8d6c34bade9c34ea66740469e2848b9d1



4. 

<<<<<<< HEAD
![image-20260130200324763](png/image-20260130200324763.png)



如何理解 toStdString？

- 如何理解 
  QByteArray ba;
  ba.resize(static_cast<int>(LOS_request.ByteSizeLong()));

- 以及如何理解这几个parsefrom？



- QString的 toStdString 是转换成 utf-8的

- protobuf   **`LOS_request.ByteSizeLong()`**  这个方式会计算二进制的长度

- #### ① `ParseFromArray(const void* data, int size)` —— **最常用**

  - **含义**：我手里有一块原始内存地址（指针）和它的长度。
  - **场景**：在 Qt 中，当你收到 `QNetworkReply` 的数据时，直接用这个。
  - **写法**：`response.ParseFromArray(ba.data(), ba.size());`

  #### ② `ParseFromString(const std::string& data)`

  - **含义**：数据已经装在一个 `std::string` 盒子里了。
  - **注意**：这里的“String”不代表它是可读的文本，它依然是二进制。只是用 `std::string` 作为容器。

  #### ③ `ParseFromIstream(std::istream* input)`

  - **含义**：从“流”里读取。
  - **场景**：如果你要从一个**本地文件**里读取保存好的 Protobuf 配置，可以使用这个，直接对接 `std::ifstream`。

  #### ④ `ParseFromCodedStream` 和 `ParseFromBoundedZeroCopyStream` —— **高级/底层**

  - **含义**：这是“零拷贝”解析。
  - **场景**：在处理每秒几十万次的高并发请求时，程序员不希望有任何多余的内存移动。它们允许解析器直接在网络缓冲区上操作。**普通业务逻辑几乎不用。**

  #### ⑤ `ParseFromCord` (谷歌特有)

  - **含义**：`Cord` 是 Google 内部使用的一种特殊字符串类型（类似不连续的字符串碎片）。
  - **场景**：你在一般的开源环境或 Qt 开发中基本见不到。





5. [protobuf] [c++]

```c++
QByteArray LoginRequest::body() const
{
    //std::string seri = LOS_request.SerializeAsString();
    //return QByteArray(seri.c_str(), static_cast<size_t>(seri.size()));
     
    QByteArray ba;
    size_t size = static_cast<size_t>(LOS_request.ByteSizeLong());
    ba.resize(size);
    LOS_request.SerializeToArray(ba.data(), size);
    return QByteArray(ba.data(), ba.size());
}
```





6. [Qt]

QNetworkAccessManager
如何理解 Qt这个类

- 整个应用只用一个实例即可

- ```c++
  // 发起请求（GET示例）
  QNetworkRequest request(QUrl("https://api.example.com/data"));
  QNetworkReply *reply = manager->get(request);
  
  // 异步处理响应
  connect(reply, &QNetworkReply::finished, [=]() {
      if (reply->error() == QNetworkReply::NoError) {
          QByteArray data = reply->readAll();
          // 处理数据
      }
      reply->deleteLater();
  });
  ```

- 



7. [rust]

```txt
构建生命周期 (Lifecycle)
当你输入 cargo build 或 cargo run 时，Cargo 的执行顺序如下：

解析依赖：Cargo 检查 Cargo.toml。

编译并运行 build.rs：

Cargo 发现根目录有 build.rs。

它先编译这个脚本，然后立即执行它。

正式编译代码：

Cargo 开始编译你的 main.rs 和其他模块。

此时，你在 main.rs 中通过 include! 宏引用的代码已经在磁盘上准备好了。

链接：生成最终的可执行文件。

运行：如果是 cargo run，此时才开始运行你的 main.rs 里的 main 函数。
```
>>>>>>> 2d7e01c8d6c34bade9c34ea66740469e2848b9d1















