1. 

```shell
cmake .. -DCMAKE_TOOLCHAIN_FILE="E:/vcpkg/scripts/buildsystems/vcpkg.cmake" -DCMAKE_BUILD_TYPE=Release
这个指令可以直接通过
set(DCMAKE_TOOLCHAIN_FILE,"") 这样么？
```

- 不支持

- 推荐:

  - ```shell
    cmake .. -DCMAKE_TOOLCHAIN_FILE=E:/vcpkg/vcpkg/scripts/buildsystems/vcpkg.cmake
    ```



2. [C++]

QByteArray 的填充方式

- ```c++
  QByteArray ba1(10, 'A'); 
  ```

  - 填充 指定个数的 字符

- ```c++
  QByteArray ba4(10, Qt::Uninitialized); 
  ```

  - 十个 字节 但是不初始化

- ```c++
  const char* str = "Hello";
  QByteArray ba1(str);  
  ```

- ```c++
  QByteArray ba2("World");  
  ```

  - C语言的初始化方式

- ```c++
  const char data[] = { 'H', 'i', '\0', '!' };
  QByteArray ba3(data, 4);
  QByteArray ba4(data, 2); 
  ```

  - 加长度 构造

- 

  ```c++
  QByteArray ba2 = QByteArray::fromRawData("Raw", 3);  // 不拷贝数据
  QByteArray ba3 = QByteArray::fromHex("48656c6c6f");  // 从十六进制字符串
  QByteArray ba4 = QByteArray::fromBase64("SGVsbG8="); // 从Base64
  QByteArray ba5 = QByteArray::fromPercentEncoding("Hello%20World%21"); 
  ```



3. [c++] [protobuf]

```c++
bool Message::ParseFromArray(const void* data, int size);
```

- **输入**：二进制数据指针和数据大小
- **输出**：`bool`，表示解析是否成功
- **作用**：将二进制数据填充到当前消息对象中

- [ ] 26_2_3



4. 

- 如何理解 toStdString？

- 如何理解 
  QByteArray ba;
  ba.resize(static_cast<int>(LOS_request.ByteSizeLong()));

- 以及如何理解这几个parsefrom？



- QString的 toStdString 是转换成 utf-8的

- protobuf   **`LOS_request.ByteSizeLong()`**  这个方式会计算二进制的长度

- #### ① `ParseFromArray(const void* data, int size)` —— **最常用**

  - **含义**：我手里有一块原始内存地址（指针）和它的长度。
  - **场景**：在 Qt 中，当你收到 `QNetworkReply` 的数据时，直接用这个。
  - **写法**：`response.ParseFromArray(ba.data(), ba.size());`

  #### ② `ParseFromString(const std::string& data)`

  - **含义**：数据已经装在一个 `std::string` 盒子里了。
  - **注意**：这里的“String”不代表它是可读的文本，它依然是二进制。只是用 `std::string` 作为容器。

  #### ③ `ParseFromIstream(std::istream* input)`

  - **含义**：从“流”里读取。
  - **场景**：如果你要从一个**本地文件**里读取保存好的 Protobuf 配置，可以使用这个，直接对接 `std::ifstream`。

  #### ④ `ParseFromCodedStream` 和 `ParseFromBoundedZeroCopyStream` —— **高级/底层**

  - **含义**：这是“零拷贝”解析。
  - **场景**：在处理每秒几十万次的高并发请求时，程序员不希望有任何多余的内存移动。它们允许解析器直接在网络缓冲区上操作。**普通业务逻辑几乎不用。**

  #### ⑤ `ParseFromCord` (谷歌特有)

  - **含义**：`Cord` 是 Google 内部使用的一种特殊字符串类型（类似不连续的字符串碎片）。
  - **场景**：你在一般的开源环境或 Qt 开发中基本见不到。





5. [protobuf] [c++]

```c++
QByteArray LoginRequest::body() const
{
    //std::string seri = LOS_request.SerializeAsString();
    //return QByteArray(seri.c_str(), static_cast<size_t>(seri.size()));
     
    QByteArray ba;
    size_t size = static_cast<size_t>(LOS_request.ByteSizeLong());
    ba.resize(size);
    LOS_request.SerializeToArray(ba.data(), size);
    return QByteArray(ba.data(), ba.size());
}
```





6. [Qt]

QNetworkAccessManager
如何理解 Qt这个类

- 整个应用只用一个实例即可

- ```c++
  // 发起请求（GET示例）
  QNetworkRequest request(QUrl("https://api.example.com/data"));
  QNetworkReply *reply = manager->get(request);
  
  // 异步处理响应
  connect(reply, &QNetworkReply::finished, [=]() {
      if (reply->error() == QNetworkReply::NoError) {
          QByteArray data = reply->readAll();
          // 处理数据
      }
      reply->deleteLater();
  });
  ```

- 



7. [rust]

```txt
构建生命周期 (Lifecycle)
当你输入 cargo build 或 cargo run 时，Cargo 的执行顺序如下：

解析依赖：Cargo 检查 Cargo.toml。

编译并运行 build.rs：

Cargo 发现根目录有 build.rs。

它先编译这个脚本，然后立即执行它。

正式编译代码：

Cargo 开始编译你的 main.rs 和其他模块。

此时，你在 main.rs 中通过 include! 宏引用的代码已经在磁盘上准备好了。

链接：生成最终的可执行文件。

运行：如果是 cargo run，此时才开始运行你的 main.rs 里的 main 函数。
```















