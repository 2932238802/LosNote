1. 

快排什么时候会退化

#### 数组已经有序（或接近有序）

#### 数组完全逆序

#### 数组中有大量重复元素

- [ ] 26_1_28



2. 

```c++
class Product { public: virtual void show() = 0; };
class ProductA : public Product { void show() { cout << "A"; } };
class ProductB : public Product { void show() { cout << "B"; } };

class SimpleFactory {
public:
    static Product* createProduct(string type) {
        if (type == "A") return new ProductA();
        if (type == "B") return new ProductB();
        return nullptr;
    }
};
```

简单工厂模式



```c++
// 抽象工厂接口
class IFactory {
public:
    virtual Product* create() = 0;
};

// 具体工厂 A
class FactoryA : public IFactory {
    Product* create() override { return new ProductA(); }
};

// 具体工厂 B
class FactoryB : public IFactory {
    Product* create() override { return new ProductB(); }
};

// 使用
IFactory* factory = new FactoryA();
Product* p = factory->create();
```

工厂方法模式

品牌加盟店



```c++
// 两个产品系列
class Phone { public: virtual void call() = 0; };
class Watch { public: virtual void alarm() = 0; };

// 抽象工厂：定义一个产品族
class IAbstractFactory {
public:
    virtual Phone* createPhone() = 0;
    virtual Watch* createWatch() = 0;
};

// 华为全家桶工厂
class HuaweiFactory : public IAbstractFactory {
    Phone* createPhone() override { return new Mate60(); }
    Watch* createWatch() override { return new HuaweiWatch(); }
};

// 苹果全家桶工厂
class AppleFactory : public IAbstractFactory {
    Phone* createPhone() override { return new IPhone15(); }
    Watch* createWatch() override { return new AppleWatch(); }
};
```

抽象工厂模式

 产品全家桶



3.[c++]

如何 更新 已经安装好了 boost库？
如何 查看 vcpkg 都安装了哪些？

- ```shell
  vcpkg list 
  ```

  - 就可以查看 自己安装了 哪些的库



- 先 git pull
- 然后 vcpkg update
- 然后 vcpkg upgrade --no-dry-run
  - vcpkg install boost --recurse 这是只更新 boost 库



4. 

- Reactor 模式系统叫你去取餐 
  - 比如 点了 份外卖
  - 外卖到了 外卖员给你打电话 你去拿
- Proactor的模式是
  - Windows 下的 `IOCP`，Boost.Asio 的核心设计
  - 外卖是直接进来放到你的桌上



![image-20260131163955165](E:\LosNote\随手笔记\png\image-20260131163955165.png)



其实 Proactor 和 Reactor 的本质区别在于 **IO 操作是由谁完成的**。

Reactor 是非阻塞同步 IO，它只通知‘就绪’，搬运数据仍需用户线程参与，这会占用 CPU 时间。

而 Proactor 是真正的异步 IO，它通知‘完成’，利用硬件 DMA 技术让数据搬运和 CPU 计算完全并行。

虽然在 Linux 上 Asio 是通过 `epoll` 模拟 Proactor，存在一层封装损耗，但在架构上它实现了**读写操作与业务逻辑的深度解耦**。尤其是面对三维扫描这种海量数据实时处理场景，Proactor 模式能让我们更容易通过‘线程池+任务队列’的方式压榨多核性能，而不需要让程序员去处理复杂的 `epoll` 状态机。



我有个问题·
那我 在 Ubuntu上面运行这个 boost库 是不是 本质上底层还是 epoll但是多了一层封装？

- **在 Ubuntu 上，Asio = epoll + 自动执行的 read/write + 回调分发**





5. [c++]

```tex
根据你这个回答
在同步编程中，你的局部变量存在栈（Stack）异步编程中，存在一个致命矛盾：“函数已死，任务未完”。

场景：你调用 async_read(socket, buffer, callback)。

矛盾：这个函数会立即返回。一旦返回，当前函数的栈帧就销毁了。如果你的 buffer 或 socket 是局部变量，它们就成了野指针。

Session 的本质：它是存放在堆（Heap）上的“记忆载体”。

为什么要创建它：我们需要一个容器，把异步操作所需的所有上下文（Socket、Buffer、协议状态）打包。只要底层的 IO 没跑完，这个容器就必须在堆里“续命”。

你来创建一个例子
就是局部这个销毁的例子
```

```c++
#include <boost/asio.hpp>
#include <iostream>
#include <memory>
#include <string>

using namespace boost::asio;
using ip::tcp;

// 【危险函数】：演示局部变量如何销毁
void dangerous_async_read(tcp::socket& socket) {
    // 1. 局部变量：buffer 存在于当前函数的“栈”上
    char stack_buffer[1024]; 
    std::string request_id = "SCAN_TASK_001";

    std::cout << "[Step 1] 发起异步读，buffer 地址: " << (void*)stack_buffer << std::endl;

    // 2. 发起异步读取
    // 注意：我们把局部变量 stack_buffer 的地址传给了 Asio
    async_read(socket, buffer(stack_buffer, 10), 
        [request_id, stack_buffer_ptr = stack_buffer](const boost::system::error_code& ec, std::size_t len) {
            // 4. 【灾难现场】：当这个 Lambda 被执行时，dangerous_async_read 已经退出了
            // 此时 stack_buffer_ptr 指向的是一块已经被回收、可能被挪作他用的栈空间
            if (!ec) {
                std::cout << "[Step 4] 收到数据，任务 ID: " << request_id << std::endl;
                // 这里的访问会引发未定义行为（可能是乱码，也可能是直接崩溃 Segfault）
                std::cout << "读到的内容是: " << stack_buffer_ptr[0] << std::endl;
            }
        });

    // 3. 函数运行到这里就结束了！
    // 一旦返回，stack_buffer 和 request_id 的原始生命周期彻底终结
    std::cout << "[Step 2] dangerous_async_read 函数执行完毕，栈帧销毁！" << std::endl;
}

int main() {
    io_context io;
    
    // 模拟一个连接（实际开发中这里是 acceptor 产生的）
    tcp::socket socket(io);
    // ... 假设此处 socket 已连接 ...

    dangerous_async_read(socket);

    std::cout << "[Step 3] 主线程开始运行 io.run()，等待 IO 完成..." << std::endl;
    
    // 只有调用 run，上面的 Lambda 才有机会在未来某个时刻被执行
    io.run(); 
    return 0;
}
```

- [ ] 26_1_31













