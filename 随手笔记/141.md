1. 

快排什么时候会退化



#### 数组已经有序（或接近有序）

#### 数组完全逆序

#### 数组中有大量重复元素



- [x] 26_1_28



2. 

```c++
class Product { public: virtual void show() = 0; };
class ProductA : public Product { void show() { cout << "A"; } };
class ProductB : public Product { void show() { cout << "B"; } };

class SimpleFactory {
public:
    static Product* createProduct(string type) {
        if (type == "A") return new ProductA();
        if (type == "B") return new ProductB();
        return nullptr;
    }
};
```

简单工厂模式



```c++
// 抽象工厂接口
class IFactory {
public:
    virtual Product* create() = 0;
};

// 具体工厂 A
class FactoryA : public IFactory {
    Product* create() override { return new ProductA(); }
};

// 具体工厂 B
class FactoryB : public IFactory {
    Product* create() override { return new ProductB(); }
};

// 使用
IFactory* factory = new FactoryA();
Product* p = factory->create();
```

工厂方法模式

品牌加盟店



```c++
// 两个产品系列
class Phone { public: virtual void call() = 0; };
class Watch { public: virtual void alarm() = 0; };

// 抽象工厂：定义一个产品族
class IAbstractFactory {
public:
    virtual Phone* createPhone() = 0;
    virtual Watch* createWatch() = 0;
};

// 华为全家桶工厂
class HuaweiFactory : public IAbstractFactory {
    Phone* createPhone() override { return new Mate60(); }
    Watch* createWatch() override { return new HuaweiWatch(); }
};

// 苹果全家桶工厂
class AppleFactory : public IAbstractFactory {
    Phone* createPhone() override { return new IPhone15(); }
    Watch* createWatch() override { return new AppleWatch(); }
};
```

抽象工厂模式

 产品全家桶





3. 

```c++
#include <unistd.h>
int dup2(int oldfd, int newfd);
```

后面输入的内容 都到前面那个oldfd里面去了

- [ ] 26_1_29





4. execlp



// 第一个参数是命令名，第二个参数是 argv[0]（通常也是命令名），之后是参数，最后必须是 NULL

execlp("ls", "ls", "-l", NULL);

- [x] 26_1_29





5. [C++]

为什么 期待和承诺 是进程间通信的一种方式？



参考例子

虽然 STL 的 `std::future` 不能直接跨进程，但在高级 IPC 框架（如 Android 的 Binder、gRPC、或自定义的消息中间件）中，逻辑是这样的：

- **调用方（进程 A）** 调用一个远程函数。

- **IPC 框架** 立即返回一个代理对象（即 Future）。

- **被调用方（进程 B）** 在后台处理逻辑，完成后将结果写入一个共享的内存区域或发送一个回执消息。

- **Promise 被填充**：当结果到达进程 A 的底层通信层时，该层会将数据“填入”之前的 Future 中。

- **通知机制**：进程 A 的 Future 变为 `ready` 状态，触发回调函数

- [ ] 26_1_29









