1. 线程之间的通信方式？以及如何正确访问临界区资源？

- 共享内存的方式
  - 同时访问同一个全局变量，静态变量或者堆上的变量
- 条件变量
  - 一个线程等待某个条件达成，另一个线程达成条件后发出信号
- 期待和承诺
  - std::future std::promise 
  - 用于获取一部任务的结果

- C++20 引入了 std::counting_semmaphore 它可以控制同时访问特定资源的线程数量

- [ ] 26_1_28



- 原子性

- 使用 `std::lock_guard` (简单) 或 `std::unique_lock` (灵活)

- 使用读写锁 (Shared Mutex) —— 读多写少

  如果你的数据经常被读取，但很少被修改，用普通的 `mutex` 会很浪费性能。

  - **C++17 `std::shared_mutex`**：
    - **读操作**：使用 `std::shared_lock`，多个线程可以同时读。
    - **写操作**：使用 `std::unique_lock`，此时禁止任何其他读写

  



2. 

如何理解 unique_lock？
如何理解这个 锁 和 lock_guard的区别？

- **特点：**
  1. 你不能中途手动解锁。
  2. 你不能手动加锁。
  3. 它的生命周期就是锁的生命周期。
- **优点：** 因为它简单，所以它的开销几乎为零（编译器优化后和手动加解锁没区别）。
- **适用场景：** 绝大多数情况。只要你只是想保护一段简单的代码块

- [x] 26_1_28

- [x] 



`std::unique_lock`：锁的“全功能版”

`unique_lock` 内部比 `lock_guard` 复杂得多，因为它维护了一个变量来记录当前锁的状态（是锁着的还是开着的）。

- **它能做而 `lock_guard` 做不到的事：**
  1. **中途解锁和再加锁**：你可以调用 `lock.unlock()` 和 `lock.lock()`。这在长函数中很有用，可以在不需要锁的时候暂时放开。
  2. **延迟加锁**：构造时可以传入 `std::defer_lock`，先不加锁，等后面有需要再锁。
  3. **尝试加锁 (Try Lock)**：可以配合超时机制。
  4. **所有权转移**：它可以被 `std::move`，意味着你可以把锁的所有权从一个函数传递到另一个函数。
  5. **配合条件变量 (Condition Variable)**：**这是最重要的一点。** `std::condition_variable` 的 `wait()` 函数必须使用 `unique_lock`

- [ ] 26_1_28



3. 

右值引用 是 C++11 引入的一种新语法（符号是 &&），它的核心目的是为了实现“移动语义”和“完美转发 ”，从而消除不必要的深度拷贝，提升程序性能

- [ ] 26_1_28



4. 模板特化
`template<>`

```c++
// 1. 通用模板
template<typename T>
class Printer {
public:
    void print(T val) { std::cout << "Generic: " << val << std::endl; }
};

// 2. 全特化：针对 char* 类型
// 此时已经没有泛型参数了，所以 template 后面是空的 <>
template<>
class Printer<char*> {
public:
    void print(char* val) { 
        std::cout << "Specialized for C-style string: " << val << std::endl; 
    }
};
```

`template<>` 告诉编译器：“我要给之前的模板写一个特例，我已经把参数定死了



5. [C++]

C++多态”是怎么做的

多态的本质是：**“一个接口，多种实现”**。根据实现的时机，C++ 的多态分为两类：

- **静态多态（编译期多态）**：包括 **模板（泛型）**、**特化**、**函数重载**。
  - *原理*：编译器在编译阶段根据类型决定调用哪个版本的代码。
  - *特点*：运行速度极快（没有额外开销），但无法在运行时改变行为。

- [x] 26_1_28



- **动态多态（运行期多态）**：这就是通常大家说的“多态”，基于 **虚函数（Virtual Functions）**。
  - *原理*：程序在运行阶段根据对象的实际类型决定调用哪个函数。
  - *特点*：非常灵活，但有微小的运行开销（虚表查询）

- [ ] 26_1_28






```c++
函数重载
#include <iostream>
using namespace std;

// 重载版本 1：处理整数
void display(int i) {
    cout << "Handling an integer: " << i << endl;
}

// 重载版本 2：处理字符串
void display(string s) {
    cout << "Handling a string: " << s << endl;
}

// 重载版本 3：处理两个参数
void display(int i, double d) {
    cout << "Handling int and double: " << i << ", " << d << endl;
}

int main() {
    display(10);             // 编译期绑定到版本 1
    display("Hello");        // 编译期绑定到版本 2
    display(10, 3.14);       // 编译期绑定到版本 3
    return 0;
}

```

```c++
函数模板
#include <iostream>

// 模板：通用的逻辑
template <typename T>
T myMax(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    // 编译器自动生成 int 版本的 myMax
    std::cout << myMax(10, 20) << std::endl; 
    
    // 编译器自动生成 double 版本的 myMax
    std::cout << myMax(3.14, 2.71) << std::endl; 
    
    return 0;
}

```

```c++
特化
#include <iostream>
#include <cstring>

// 通用模板
template <typename T>
bool isEqual(T a, T b) {
    return a == b;
}

// 全特化：针对 const char* 类型
// 理由：直接比较 char* 会比较指针地址，而我们想比较字符串内容
template <>
bool isEqual<const char*>(const char* a, const char* b) {
    std::cout << "(Specialized version for C-strings) ";
    return strcmp(a, b) == 0;
}

int main() {
    int x = 10, y = 10;
    std::cout << isEqual(x, y) << std::endl; // 走通用模板

    const char* s1 = "hello";
    const char* s2 = "hello";
    std::cout << isEqual(s1, s2) << std::endl; // 走特化版本
    
    return 0;
}


```

















